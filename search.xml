<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>绕过NX</title>
      <link href="/2023/04/13/rao-guo-nx/"/>
      <url>/2023/04/13/rao-guo-nx/</url>
      
        <content type="html"><![CDATA[<h2 id="1-绕过NX保护的几种常见方法"><a href="#1-绕过NX保护的几种常见方法" class="headerlink" title="1.绕过NX保护的几种常见方法"></a>1.绕过NX保护的几种常见方法</h2><h3 id="1-Return-to-libc攻击"><a href="#1-Return-to-libc攻击" class="headerlink" title="1.Return-to-libc攻击"></a>1.Return-to-libc攻击</h3><p>利用程序中已经存在的GOT表项和PLT表项，将程序流程跳转到libc库的某个函数，从而绕过NX保护。<br>例如，在一个程序中存在一个漏洞，可以通过溢出栈来覆盖函数调用时保存返回地址的位置。如果该程序被编译成启用了NX保护，则无法直接在栈上注入shellcode。但是，我们可以利用libc库中已有的函数来实现任意指令执行。比如，我们可以覆盖函数调用时的返回地址为system()函数的地址，然后将需要执行的命令作为参数传递给system()函数。<br><a href="https://www.yuque.com/hxfqg9/bin/ug9gx5#fdaxg">具体参考</a></p><h3 id="2-Return-to-ROP攻击"><a href="#2-Return-to-ROP攻击" class="headerlink" title="2.Return-to-ROP攻击"></a>2.Return-to-ROP攻击</h3><p>利用程序中一些已有的代码段或者库中的代码段，构造ROP链实现任意指令执行。具体来说，通过伪造栈帧，将多个gadget组合起来构成ROP链，从而跳转到程序中其他位置执行恶意代码。<br>例如，在某个程序中存在一个漏洞，我们可以通过缓冲区溢出来控制程序的执行流程，但是无法直接执行任意指令。这种情况下，我们可以使用ROP技术来构造一条由多个gadget组成的链，从而达到执行任意指令的目的。下面是一些常见的gadget类型：<br>pop reg; ret：弹出寄存器reg的值，并将代码流程跳转到返回地址。<br>mov reg1, reg2; ret：将reg2中的值赋给reg1，并将代码流程跳转到返回地址。<br>add reg1, reg2; ret：将reg1和reg2相加，并将代码流程跳转到返回地址。<br>xor reg1, reg2; ret：将reg1和reg2进行异或，并将代码流程跳转到返回地址。<br>call [reg];：调用寄存器reg中存储的函数地址<br>可以使用ROPgadget等工具自动化生成ROP链<br><a href="https://ropemporium.com/challenge/split.html">例题</a><br><a href="https://xz.aliyun.com/t/3402">ROP</a><a href="https://hollk.blog.csdn.net/article/details/105913705?spm=1001.2014.3001.5502">BROP</a><a href="https://hollk.blog.csdn.net/article/details/107512670?spm=1001.2014.3001.5502">SROP</a></p><h3 id="3-Ret2dlresolve攻击"><a href="#3-Ret2dlresolve攻击" class="headerlink" title="3.Ret2dlresolve攻击"></a>3.Ret2dlresolve攻击</h3><p>通过覆盖GOT表项，将程序跳转到自己编写的dlresolve函数，通过解析动态链接库中的符号，获取需要的函数地址，再跳转到该函数实现任意指令执行和代码注入。<br>Ret2dlresolve攻击可以通过覆盖程序的GOT表或PLT表，将程序跳转到自定义的解析动态链接库符号的函数中，获取到需要调用的函数地址，并将程序流程跳转到该函数。下面是一个简单的实例，在某个程序中存在栈溢出漏洞，我们可以利用Ret2dlresolve攻击来执行任意指令。具体来说，我们可以构造一个伪造的DT_NEEDED段，然后在程序中使用dlopen()函数打开这个动态链接库，从而使得程序在运行时会解析这个DT_NEEDED段中的符号。接着，我们可以通过覆盖GOT表项，将程序跳转到我们自己编写的dlresolve函数，该函数会解析需要调用的函数地址并返回给程序，最终跳转到该函数实现代码注入<br><a href="http://pwn4.fun/2016/11/09/Return-to-dl-resolve/">具体参考1</a><br><a href="https://hollk.blog.csdn.net/article/details/107378159?spm=1001.2014.3001.5502">具体参考</a></p><h3 id="4-ret2plt攻击"><a href="#4-ret2plt攻击" class="headerlink" title="4.ret2plt攻击"></a>4.ret2plt攻击</h3><p>可以通过覆盖程序的PLT表项，将程序跳转到某个库函数的PLT入口，在绕过NX保护的同时，也可以实现代码注入。<br>在某个程序中存在栈溢出漏洞，但是启用了NX保护。我们可以使用ret2plt攻击，通过覆盖程序的PLT表项，将程序跳转到某个库函数的PLT入口，并向函数传递参数，从而实现代码注入和任意指令执行。例如，我们可以使用libc库中的system()函数来执行任意命令。具体来说，我们可以通过覆盖程序的PLT表项，将程序跳转到system()函数的PLT入口，然后将需要执行的命令作为参数传递给system()函数。<br><a href="https://ctftime.org/task/13273">例题</a><br><a href="https://blog.csdn.net/guilanl/article/details/70227392">具体参考</a></p><h3 id="5-使用栈迁移技术"><a href="#5-使用栈迁移技术" class="headerlink" title="5.使用栈迁移技术"></a>5.使用栈迁移技术</h3><p>在一些特殊情况下，无法直接修改返回地址，但是可以通过栈迁移技术，将栈上存储的数据移动到另外一块内存区域，从而绕过NX保护。<br>在某些情况下，无法直接修改返回地址或者调用其他函数来实现代码注入。但是，我们可以使用栈迁移技术，在栈上创建一块新的内存区域，将原始的栈数据复制到这里，然后在新的栈上进行操作。具体来说，我们可以通过覆盖函数调用时的参数，使得程序执行到一个特定的函数，该函数会执行栈迁移操作。栈迁移函数会在堆上申请一块新的内存区域，将原始的栈数据复制到这个区域中，并且修改返回地址，使得程序在执行完栈迁移操作后会跳转到新的栈上。在新的栈上，我们可以自由地进行任意指令执行和代码注入。<br><a href="https://www.cnblogs.com/max1z/p/15299000.html">具体参考</a></p><h3 id="6-JIT（Just-In-Time）编译攻击"><a href="#6-JIT（Just-In-Time）编译攻击" class="headerlink" title="6.JIT（Just-In-Time）编译攻击"></a>6.JIT（Just-In-Time）编译攻击</h3><p>创建一个可执行内存区域，将shellcode动态生成到这个区域，并且跳转到该区域执行代码。<br>JIT攻击通常需要程序本身存在一定的漏洞，如栈溢出漏洞等。下面是一个简单的实例，在某个程序中存在栈溢出漏洞，我们可以构造恶意输入，使得程序执行时会将shellcode写入一个可执行的内存区域，并且跳转到该区域执行。例如，我们可以使用mmap()函数将一块可读写可执行的内存映射到进程空间，然后将shellcode写入这个内存区域，并手动在栈上伪造一个返回地址，使得程序执行完shellcode后会跳转到正确的位置。<br><a href="https://github.com/scwuaptx/CTF/blob/master/2014-writeup/pwnable/exploitable/exploitable.md">例题</a></p><h3 id="7-使用mmap等函数映射内存"><a href="#7-使用mmap等函数映射内存" class="headerlink" title="7.使用mmap等函数映射内存"></a>7.使用mmap等函数映射内存</h3><p>通过调用mmap等函数，将一个可读写可执行的内存区域映射到进程空间，然后将shellcode写入这个内存区域并执行。<br>在某个程序中存在栈溢出漏洞，但是启用了NX保护。我们可以使用mmap()函数将一块可读写可执行的内存映射到进程空间，然后将shellcode写入这个内存区域，并手动在栈上伪造一个返回地址，使得程序执行完shellcode后会跳转到正确的位置。具体来说，我们可以首先调用mmap()函数映射一块可读写可执行的内存，然后使用strcpy()等函数将shellcode复制到这个内存区域，并在栈上伪造一个返回地址，使得程序执行完shellcode后会跳转到正确的位置。<br><a href="https://github.com/hitcon2016/exploit/blob/master/pwn/echo/README.md">例题</a></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二级制调试工具</title>
      <link href="/2023/04/04/er-jin-zhi-diao-shi-gong-ju/"/>
      <url>/2023/04/04/er-jin-zhi-diao-shi-gong-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="1-strace"><a href="#1-strace" class="headerlink" title="1.strace"></a>1.strace</h2><p><code>strace</code> 是一个在 Linux 系统上常用的调试工具，可以用来跟踪进程的系统调用和信号。它可以帮助开发者了解程序的运行情况，发现可能存在的问题和错误。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><pre class="line-numbers language-none"><code class="language-none">strace [options] command [args]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，<code>command</code> 表示需要跟踪的程序，<code>args</code> 表示程序的参数。<code>options</code> 是一些可选参数，用于指定跟踪的选项。</p><p>例如，要跟踪运行 <code>ls</code> 命令的系统调用情况，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果会输出 <code>ls</code> 命令的所有系统调用。如果想将结果输出到文件中，可以使用 <code>-o</code> 选项：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-o</span> trace.log <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时，<code>ls</code> 命令的系统调用信息会输出到 <code>trace.log</code> 文件中。<br><code>strace</code> 还提供了许多其它的选项，如 <code>-p</code> 选项用于跟踪指定进程的系统调用，<code>-f</code> 选项用于跟踪子进程的系统调用，<code>-e</code> 选项用于指定需要跟踪的系统调用类型等等。可以使用 <code>man strace</code> 命令查看完整的帮助文档。<br>除了基本的使用方法，<code>strace</code> 还提供了许多高级的选项和功能，下面介绍几个常用的选项和用法。</p><h3 id="跟踪某个系统调用"><a href="#跟踪某个系统调用" class="headerlink" title="跟踪某个系统调用"></a>跟踪某个系统调用</h3><p>有时候我们只想跟踪某个特定的系统调用，可以使用 <code>-e</code> 选项来指定：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-e</span> <span class="token function">open</span> <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令只会跟踪 <code>ls</code> 命令中的 <code>open</code> 系统调用。</p><h3 id="跟踪系统调用的参数和返回值"><a href="#跟踪系统调用的参数和返回值" class="headerlink" title="跟踪系统调用的参数和返回值"></a>跟踪系统调用的参数和返回值</h3><p>通过 <code>-v</code> 选项，可以让 <code>strace</code> 输出系统调用的参数和返回值：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-v</span> <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>ls</code> 命令执行过程中每个系统调用的参数和返回值。</p><h3 id="跟踪动态链接库"><a href="#跟踪动态链接库" class="headerlink" title="跟踪动态链接库"></a>跟踪动态链接库</h3><p>许多程序在运行期间会动态链接一些库文件，可以使用 <code>-e trace=dl</code> 选项来跟踪这些动态链接库的加载情况：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-e</span> <span class="token assign-left variable">trace</span><span class="token operator">=</span>dl <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>ls</code> 命令动态链接的库文件的加载情况。</p><h3 id="过滤输出"><a href="#过滤输出" class="headerlink" title="过滤输出"></a>过滤输出</h3><p><code>strace</code> 输出的信息可能会非常多，可以使用 <code>-e trace=</code> 选项来过滤输出。例如，要只输出 <code>open</code> 和 <code>read</code> 两个系统调用的信息，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-e</span> <span class="token assign-left variable">trace</span><span class="token operator">=</span>open,read <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令只会输出 <code>ls</code> 命令中的 <code>open</code> 和 <code>read</code> 系统调用的信息。</p><h3 id="输出调用时间"><a href="#输出调用时间" class="headerlink" title="输出调用时间"></a>输出调用时间</h3><p>使用 <code>-T</code> 选项可以让 <code>strace</code> 输出每个系统调用的时间戳，用于分析程序的性能瓶颈：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-T</span> <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>ls</code> 命令执行过程中每个系统调用的时间戳。</p><h3 id="跟踪子进程"><a href="#跟踪子进程" class="headerlink" title="跟踪子进程"></a>跟踪子进程</h3><p>有些程序会创建子进程，可以使用 <code>-f</code> 选项来跟踪子进程的系统调用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-f</span> firefox<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会跟踪 <code>firefox</code> 浏览器及其所有子进程的系统调用。</p><p>下面再介绍一些 <code>strace</code> 的高级选项和用法：</p><h3 id="输出调用堆栈"><a href="#输出调用堆栈" class="headerlink" title="输出调用堆栈"></a>输出调用堆栈</h3><p>使用 <code>-c</code> 选项可以让 <code>strace</code> 输出每个系统调用的调用次数和耗时总和。如果再加上 <code>-f</code> 选项，还可以输出每个子进程的调用次数和耗时总和：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-c</span> <span class="token parameter variable">-f</span> firefox<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>firefox</code> 浏览器及其所有子进程每个系统调用的调用次数和耗时总和。</p><h3 id="跟踪文件操作"><a href="#跟踪文件操作" class="headerlink" title="跟踪文件操作"></a>跟踪文件操作</h3><p>使用 <code>-e trace=file</code> 选项可以让 <code>strace</code> 跟踪文件操作的系统调用，如 <code>open</code>、<code>read</code>、<code>write</code> 等。如果再加上 <code>-e trace=network</code> 选项，还可以跟踪网络操作的系统调用，如 <code>socket</code>、<code>connect</code>、<code>send</code>、<code>recv</code> 等：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-e</span> <span class="token assign-left variable">trace</span><span class="token operator">=</span>file,network <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>ls</code> 命令执行过程中的文件操作和网络操作的系统调用。</p><h3 id="跟踪系统信号"><a href="#跟踪系统信号" class="headerlink" title="跟踪系统信号"></a>跟踪系统信号</h3><p>使用 <code>-e trace=signal</code> 选项可以让 <code>strace</code> 跟踪系统信号的发生情况：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-e</span> <span class="token assign-left variable">trace</span><span class="token operator">=</span>signal firefox<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>firefox</code> 浏览器及其所有子进程接收到的系统信号。</p><h3 id="跟踪进程的系统调用时间"><a href="#跟踪进程的系统调用时间" class="headerlink" title="跟踪进程的系统调用时间"></a>跟踪进程的系统调用时间</h3><p>使用 <code>-T -ttt</code> 选项可以让 <code>strace</code> 输出每个系统调用的相对时间和绝对时间：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-T</span> <span class="token parameter variable">-ttt</span> <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>ls</code> 命令执行过程中每个系统调用的相对时间和绝对时间。</p><h3 id="跟踪进程的系统调用错误"><a href="#跟踪进程的系统调用错误" class="headerlink" title="跟踪进程的系统调用错误"></a>跟踪进程的系统调用错误</h3><p>使用 <code>-e trace=error</code> 选项可以让 <code>strace</code> 跟踪进程的系统调用错误：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-e</span> <span class="token assign-left variable">trace</span><span class="token operator">=</span>error <span class="token function">ls</span> /nonexistent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>ls</code> 命令执行过程中发生的系统调用错误。</p><h2 id="2-ltrace"><a href="#2-ltrace" class="headerlink" title="2.ltrace"></a>2.ltrace</h2><p><code>ltrace</code> 是 Linux 下的一款动态库调用跟踪工具，可以跟踪程序执行时所调用的动态库函数，并输出它们的参数和返回值。</p><p>和 <code>strace</code> 类似，<code>ltrace</code> 也可以用于调试程序，查找程序中的问题，或者分析程序的性能瓶颈等。</p><p>下面介绍一些 <code>ltrace</code> 的基本用法和选项：</p><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>ltrace</code> 的基本用法和 <code>strace</code> 类似，只需要在命令前加上 <code>ltrace</code> 即可，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会跟踪 <code>ls</code> 命令所调用的动态库函数，并输出它们的参数和返回值。</p><h3 id="跟踪指定的函数"><a href="#跟踪指定的函数" class="headerlink" title="跟踪指定的函数"></a>跟踪指定的函数</h3><p>可以使用 <code>-e</code> 选项来指定要跟踪的函数，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-e</span> getenv <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会跟踪 <code>ls</code> 命令中调用 <code>getenv</code> 函数的情况，并输出它的参数和返回值。</p><h3 id="过滤输出-1"><a href="#过滤输出-1" class="headerlink" title="过滤输出"></a>过滤输出</h3><p>和 <code>strace</code> 一样，<code>ltrace</code> 的输出也可能非常多，可以使用 <code>-c</code> 选项来统计函数调用次数和耗时总和，或者使用 <code>-S</code> 选项来按照函数调用次数或者耗时排序输出。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p><code>ltrace</code> 的输出格式可以使用 <code>-n</code> 选项来指定，目前支持的格式有 <code>raw</code>、<code>call</code> 和 <code>symaddr</code>。其中，<code>raw</code> 格式输出原始的函数调用信息，<code>call</code> 格式输出函数名和参数，<code>symaddr</code> 格式输出函数名和地址。</p><p>例如，要输出 <code>ls</code> 命令中调用的函数名和地址，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-n</span> symaddr <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="过滤动态链接库"><a href="#过滤动态链接库" class="headerlink" title="过滤动态链接库"></a>过滤动态链接库</h3><p>有些程序会调用很多的动态链接库，可以使用 <code>-x</code> 选项来过滤掉不需要跟踪的动态链接库。例如，要只跟踪 <code>libc</code> 动态链接库中的函数调用，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-x</span> libc <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面再介绍一些 <code>ltrace</code> 的高级选项和用法：</p><h3 id="跟踪指定进程"><a href="#跟踪指定进程" class="headerlink" title="跟踪指定进程"></a>跟踪指定进程</h3><p>可以使用 <code>-p</code> 选项来跟踪指定进程的动态库函数调用情况。例如，要跟踪进程 ID 为 1234 的进程的动态库函数调用，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-p</span> <span class="token number">1234</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="跟踪所有进程"><a href="#跟踪所有进程" class="headerlink" title="跟踪所有进程"></a>跟踪所有进程</h3><p>可以使用 <code>-a</code> 选项来跟踪所有进程的动态库函数调用情况。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-a</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="跟踪线程"><a href="#跟踪线程" class="headerlink" title="跟踪线程"></a>跟踪线程</h3><p>可以使用 <code>-t</code> 选项来跟踪线程的动态库函数调用情况。例如，要跟踪进程 ID 为 1234 的进程中线程 ID 为 5678 的线程的动态库函数调用，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-p</span> <span class="token number">1234</span> <span class="token parameter variable">-t</span> <span class="token number">5678</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="跟踪库函数的递归调用"><a href="#跟踪库函数的递归调用" class="headerlink" title="跟踪库函数的递归调用"></a>跟踪库函数的递归调用</h3><p>可以使用 <code>-L</code> 选项来跟踪库函数的递归调用情况。例如，要跟踪 <code>strlen</code> 函数的递归调用情况，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-L</span> strlen abcdefg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="跟踪函数库的系统调用"><a href="#跟踪函数库的系统调用" class="headerlink" title="跟踪函数库的系统调用"></a>跟踪函数库的系统调用</h3><p>可以使用 <code>-s</code> 选项来跟踪函数库的系统调用。例如，要跟踪 <code>libc</code> 动态链接库中的系统调用，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-s</span> libc <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="跟踪函数库的库函数"><a href="#跟踪函数库的库函数" class="headerlink" title="跟踪函数库的库函数"></a>跟踪函数库的库函数</h3><p>可以使用 <code>-r</code> 选项来跟踪函数库的库函数。例如，要跟踪 <code>libc</code> 动态链接库中的 <code>malloc</code> 函数的调用情况，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-r</span> libc malloc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-strings"><a href="#3-strings" class="headerlink" title="3.strings"></a>3.strings</h2><p><code>strings</code> 是一个 Linux&#x2F;Unix 命令行工具，它可以从一个二进制文件中提取所有的可打印字符串，即 ASCII 码表中的可见字符序列。这些字符串包括程序代码中的字符串常量、错误信息、调试信息等。</p><p>使用 <code>strings</code> 命令可以帮助我们快速地查看一个二进制文件中包含的文本信息，有助于分析程序的功能和特性。</p><p>下面是 <code>strings</code> 命令的一些基本用法和选项：</p><h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>strings</code> 命令的基本用法非常简单，只需要在命令行中指定要提取字符串的二进制文件即可，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings /usr/bin/ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 文件中的所有可打印字符串。</p><h3 id="指定字符串长度"><a href="#指定字符串长度" class="headerlink" title="指定字符串长度"></a>指定字符串长度</h3><p>默认情况下，<code>strings</code> 命令会提取所有长度大于等于 4 的可打印字符串，可以使用 <code>-n</code> 选项来指定最小字符串长度，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings <span class="token parameter variable">-n</span> <span class="token number">8</span> /usr/bin/ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 文件中所有长度大于等于 8 的可打印字符串。</p><h3 id="指定字符集"><a href="#指定字符集" class="headerlink" title="指定字符集"></a>指定字符集</h3><p>默认情况下，<code>strings</code> 命令只会提取 ASCII 字符集中的可打印字符，可以使用 <code>-e</code> 选项来指定要提取的字符集，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings <span class="token parameter variable">-e</span> S /usr/bin/ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 文件中所有 ISO-8859-1 字符集中的可打印字符。</p><h3 id="输出偏移地址"><a href="#输出偏移地址" class="headerlink" title="输出偏移地址"></a>输出偏移地址</h3><p>可以使用 <code>-t</code> 选项来输出字符串在文件中的偏移地址，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings <span class="token parameter variable">-t</span> x /usr/bin/ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 文件中所有可打印字符串，并输出它们在文件中的偏移地址。</p><h3 id="忽略-NUL-字符"><a href="#忽略-NUL-字符" class="headerlink" title="忽略 NUL 字符"></a>忽略 NUL 字符</h3><p>默认情况下，<code>strings</code> 命令会将 NUL 字符（ASCII 码为 0）作为字符串的终止符，可以使用 <code>-a</code> 选项来忽略 NUL 字符，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings <span class="token parameter variable">-a</span> /usr/bin/ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 文件中所有可打印字符串，并将 NUL 字符作为普通字符处理。</p><h3 id="过滤字符串"><a href="#过滤字符串" class="headerlink" title="过滤字符串"></a>过滤字符串</h3><p>可以使用管道符号 <code>|</code> 将 <code>strings</code> 命令的输出传递给 <code>grep</code> 命令，从而过滤掉不需要的字符串，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings /usr/bin/ls <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"ls --color"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 文件中所有可打印字符串，并过滤掉不包含字符串 “ls –color” 的行。</p><p>下面再介绍一些 <code>strings</code> 的高级选项和用法：</p><h3 id="提取多个文件"><a href="#提取多个文件" class="headerlink" title="提取多个文件"></a>提取多个文件</h3><p>可以在命令行中指定多个二进制文件，<code>strings</code> 命令将会提取它们中所有的可打印字符串。例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings /usr/bin/ls /usr/bin/cat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 和 <code>/usr/bin/cat</code> 文件中所有可打印字符串。</p><h3 id="递归提取字符串"><a href="#递归提取字符串" class="headerlink" title="递归提取字符串"></a>递归提取字符串</h3><p>可以使用 <code>-r</code> 选项来递归地提取目录中所有的二进制文件中的可打印字符串，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings <span class="token parameter variable">-r</span> /usr/bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会递归地提取 <code>/usr/bin</code> 目录中所有二进制文件中的可打印字符串。</p><h3 id="提取-ELF-文件符号表"><a href="#提取-ELF-文件符号表" class="headerlink" title="提取 ELF 文件符号表"></a>提取 ELF 文件符号表</h3><p>可以使用 <code>-a</code> 选项来提取 ELF 文件的符号表中的字符串，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings <span class="token parameter variable">-a</span> /usr/lib/libc.so.6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/lib/libc.so.6</code> 文件中符号表中的所有字符串。</p><h3 id="指定输出文件"><a href="#指定输出文件" class="headerlink" title="指定输出文件"></a>指定输出文件</h3><p>可以使用 <code>&gt;</code> 符号将 <code>strings</code> 命令的输出重定向到文件中，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings /usr/bin/ls <span class="token operator">></span> ls_strings.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 文件中所有可打印字符串，并将它们保存到 <code>ls_strings.txt</code> 文件中。</p><h3 id="使用正则表达式匹配字符串"><a href="#使用正则表达式匹配字符串" class="headerlink" title="使用正则表达式匹配字符串"></a>使用正则表达式匹配字符串</h3><p>可以使用 <code>-o</code> 选项和正则表达式来匹配要提取的字符串。例如，要提取所有以 “hello” 开头的字符串，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings <span class="token parameter variable">-o</span> /usr/bin/ls <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"^hello"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
